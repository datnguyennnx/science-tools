'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { radixSortGenerator } from '../algorithms'

export const radixSortData: SortAlgorithm = {
  id: 'radixSort',
  name: 'Radix Sort',
  description:
    'Dating back to the work of Herman Hollerith in 1887 for tabulating machines, Radix Sort is a non-comparative sorting algorithm that sorts data with integer keys by grouping keys by individual digits which share the same significant position and value. It processes digits from either the least significant digit (LSD) or most significant digit (MSD). This approach avoids direct comparisons and can be very efficient for certain types of data, particularly when the range of key values is limited. The version described here is typically for non-negative integers; handling signed integers requires modifications (e.g., sorting by absolute values then handling signs, or processing negative numbers separately). For descending order, a common approach is to sort in ascending order and then reverse the resulting list.',
  generator: radixSortGenerator,
  complexity: { time: { best: 'O(nk)', average: 'O(nk)', worst: 'O(nk)' }, space: 'O(n + k)' },
  origin: { name: 'Herman Hollerith', year: 1887 },
  img: 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/42/Hollerith.jpg/250px-Hollerith.jpg',
  pseudoCodes: {
    plaintext: [
      'procedure radixSort(list)',
      '  maxVal = findMaxValue(list)',
      '  place = 1',
      '  while maxVal / place >= 1',
      '    countingSortByDigit(list, place)',
      '    place = place * 10',
      '  end while',
      'end procedure',
      '',
      'procedure countingSortByDigit(list, place)',
      '  n = length of list',
      '  output = array of size n',
      '  count = array of 10 zeros',
      '',
      '  for i = 0 to n - 1',
      '    digit = (list[i] / place) mod 10',
      '    count[digit] = count[digit] + 1',
      '  end for',
      '',
      '  for i = 1 to 9',
      '    count[i] = count[i] + count[i - 1]',
      '  end for',
      '',
      '  for i = n - 1 down to 0',
      '    digit = (list[i] / place) mod 10',
      '    output[count[digit] - 1] = list[i]',
      '    count[digit] = count[digit] - 1',
      '  end for',
      '',
      '  for i = 0 to n - 1',
      '    list[i] = output[i]',
      '  end for',
      'end procedure',
    ],
    c: [
      '#include <stdlib.h>',
      '#include <string.h>',
      '#include <stdbool.h>',
      '',
      'int getMax(int arr[], int n) {',
      '  if (n == 0) return 0;',
      '  int maxVal = arr[0];',
      '  for (int i = 1; i < n; i++) {',
      '    if (arr[i] > maxVal) maxVal = arr[i];',
      '  }',
      '  return maxVal;',
      '}',
      '',
      'void countingSortForRadix(int arr[], int n, int place) {',
      '  if (n == 0) return;',
      '  int* output = (int*)malloc(n * sizeof(int));',
      '  if (!output) return;',
      '  int count[10];',
      '  memset(count, 0, sizeof(count));',
      '',
      '  for (int i = 0; i < n; i++) {',
      '    count[(arr[i] / place) % 10]++;',
      '  }',
      '',
      '  for (int i = 1; i < 10; i++) {',
      '    count[i] += count[i - 1];',
      '  }',
      '',
      '  for (int i = n - 1; i >= 0; i--) {',
      '    output[count[(arr[i] / place) % 10] - 1] = arr[i];',
      '    count[(arr[i] / place) % 10]--;',
      '  }',
      '',
      '  for (int i = 0; i < n; i++) {',
      '    arr[i] = output[i];',
      '  }',
      '  free(output);',
      '}',
      '',
      'void reverse_array(int arr[], int n) {',
      '  int start = 0, end = n - 1;',
      '  while (start < end) {',
      '    int temp = arr[start];',
      '    arr[start] = arr[end];',
      '    arr[end] = temp;',
      '    start++;',
      '    end--;',
      '  }',
      '}',
      '',
      'void radixSort(int arr[], int n, bool ascending) {',
      '  if (n == 0) return;',
      '  int maxVal = getMax(arr, n);',
      '  for (int place = 1; maxVal / place > 0; place *= 10) {',
      '    countingSortForRadix(arr, n, place);',
      '  }',
      '  if (!ascending) {',
      '    reverse_array(arr, n);',
      '  }',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <algorithm>',
      '#include <array>',
      '#include <stdbool.h>',
      '',
      'int getMax(const std::vector<int>& arr) {',
      '  if (arr.empty()) return 0;',
      '  return *std::max_element(arr.begin(), arr.end());',
      '}',
      '',
      'void countingSortForRadix(std::vector<int>& arr, int place) {',
      '  int n = arr.size();',
      '  if (n == 0) return;',
      '  std::vector<int> output(n);',
      '  std::array<int, 10> count{};',
      '',
      '  for (int i = 0; i < n; i++) {',
      '    count[(arr[i] / place) % 10]++;',
      '  }',
      '',
      '  for (int i = 1; i < 10; i++) {',
      '    count[i] += count[i - 1];',
      '  }',
      '',
      '  for (int i = n - 1; i >= 0; i--) {',
      '    output[count[(arr[i] / place) % 10] - 1] = arr[i];',
      '    count[(arr[i] / place) % 10]--;',
      '  }',
      '',
      '  for (int i = 0; i < n; i++) {',
      '    arr[i] = output[i];',
      '  }',
      '}',
      '',
      'void radixSort(std::vector<int>& arr, bool ascending) {',
      '  if (arr.empty()) return;',
      '  int maxVal = getMax(arr);',
      '  for (int place = 1; maxVal / place > 0; place *= 10) {',
      '    countingSortForRadix(arr, place);',
      '  }',
      '  if (!ascending) {',
      '    std::reverse(arr.begin(), arr.end());',
      '  }',
      '}',
    ],
    python: [
      'def counting_sort_for_radix(arr, place):',
      '    n = len(arr)',
      '    output = [0] * n',
      '    count = [0] * 10',
      '',
      '    for i in range(n):',
      '        digit = (arr[i] // place) % 10',
      '        count[digit] += 1',
      '',
      '    for i in range(1, 10):',
      '        count[i] += count[i - 1]',
      '',
      '    i = n - 1',
      '    while i >= 0:',
      '        digit = (arr[i] // place) % 10',
      '        output[count[digit] - 1] = arr[i]',
      '        count[digit] -= 1',
      '        i -= 1',
      '',
      '    for i in range(n):',
      '        arr[i] = output[i]',
      '',
      'def radix_sort(arr, ascending=True):',
      '    if not arr:',
      '        return arr',
      '    max_val = 0',
      '    if arr:',
      '        max_val = max(arr)',
      '    ',
      '    place = 1',
      '    while max_val // place > 0:',
      '        counting_sort_for_radix(arr, place)',
      '        place *= 10',
      '    ',
      '    if not ascending:',
      '        arr.reverse()',
      '        ',
      '    return arr',
    ],
  },
  pseudoCodeMapping: {
    0: { c: [47], cpp: [33], python: [21] },
    1: { c: [49], cpp: [35], python: [25] },
    2: { c: [50], cpp: [36], python: [28] },
    3: { c: [50], cpp: [36], python: [29] },
    4: { c: [51], cpp: [37], python: [30] },
    5: { c: [50], cpp: [36], python: [31] },
    6: { c: [50], cpp: [36], python: [29] },
    7: { c: [55], cpp: [41], python: [35] },

    9: { c: [13], cpp: [10], python: [0] },
    10: { c: [14], cpp: [11], python: [1] },
    11: { c: [15], cpp: [13], python: [2] },
    12: { c: [17], cpp: [14], python: [3] },
    14: { c: [20], cpp: [16], python: [5] },
    15: { c: [21], cpp: [17], python: [6] },
    16: { c: [21], cpp: [17], python: [7] },
    17: { c: [20], cpp: [16], python: [5] },
    19: { c: [24], cpp: [20], python: [9] },
    20: { c: [25], cpp: [21], python: [10] },
    21: { c: [24], cpp: [20], python: [9] },
    23: { c: [28], cpp: [24], python: [12, 13] },
    24: { c: [29], cpp: [25], python: [14] },
    25: { c: [29], cpp: [25], python: [15] },
    26: { c: [30], cpp: [26], python: [16] },
    27: { c: [28], cpp: [24], python: [12] },
    29: { c: [33], cpp: [29], python: [19] },
    30: { c: [34], cpp: [30], python: [20] },
    31: { c: [33], cpp: [29], python: [19] },
    32: { c: [36], cpp: [32], python: [20] },
  },
  hasAdvancedAuxiliaryVisuals: true,
}
