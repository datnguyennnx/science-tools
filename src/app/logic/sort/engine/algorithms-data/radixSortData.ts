'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { radixSortGenerator } from '../algorithms'

export const radixSortData: SortAlgorithm = {
  id: 'radixSort',
  name: 'Radix Sort',
  description:
    'Dating back to the work of Herman Hollerith in 1887 for tabulating machines, Radix Sort is a non-comparative sorting algorithm that sorts data with integer keys by grouping keys by individual digits which share the same significant position and value. It processes digits from either the least significant digit (LSD) or most significant digit (MSD). This approach avoids direct comparisons and can be very efficient for certain types of data, particularly when the range of key values is limited. The version described here is typically for non-negative integers; handling signed integers requires modifications (e.g., sorting by absolute values then handling signs, or processing negative numbers separately). For descending order, a common approach is to sort in ascending order and then reverse the resulting list.',
  generator: radixSortGenerator,
  complexity: { time: { best: 'O(nk)', average: 'O(nk)', worst: 'O(nk)' }, space: 'O(n + k)' },
  origin: { name: 'Herman Hollerith', year: 1887 },
  img: 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/42/Hollerith.jpg/250px-Hollerith.jpg',
  pseudoCodes: {
    plaintext: [
      'procedure radixSort(list) // Assumes non-negative integers',
      '  maxVal = findMaxValue(list) // Find the maximum value to know the number of digits',
      '  place = 1',
      '  while maxVal / place >= 1',
      '    countingSortByDigit(list, place)',
      '    place = place * 10',
      '  end while',
      'end procedure',
      '',
      'procedure countingSortByDigit(list, place)',
      '  n = length of list',
      '  output = array of size n',
      '  count = array of 10 zeros',
      '',
      '  for i = 0 to n - 1',
      '    digit = (list[i] / place) mod 10 // Assumes list[i] is non-negative for direct digit extraction',
      '    count[digit] = count[digit] + 1',
      '  end for',
      '',
      '  for i = 1 to 9',
      '    count[i] = count[i] + count[i - 1]',
      '  end for',
      '',
      '  for i = n - 1 down to 0',
      '    digit = (list[i] / place) mod 10',
      '    output[count[digit] - 1] = list[i]',
      '    count[digit] = count[digit] - 1',
      '  end for',
      '',
      '  for i = 0 to n - 1',
      '    list[i] = output[i]',
      '  end for',
      'end procedure',
    ],
    c: [
      '#include <stdlib.h> // For malloc, free',
      '#include <string.h> // For memset',
      '',
      'int getMax(int arr[], int n) { // Finds maximum value, assumes non-negative for Radix logic',
      '  int maxVal = 0; // Initialize with 0 for non-negative array or handle empty properly',
      '  if (n == 0) return 0;',
      '  maxVal = arr[0]; // Assume arr[0] is non-negative',
      '  for (int i = 1; i < n; i++) {',
      '    if (arr[i] > maxVal) maxVal = arr[i]; // Assumes arr[i] is non-negative',
      '  }',
      '  return maxVal;',
      '}',
      '',
      'void countingSortForRadix(int arr[], int n, int place) {',
      '  int* output = (int*)malloc(n * sizeof(int));',
      '  int count[10];',
      '  memset(count, 0, sizeof(count));',
      '',
      '  for (int i = 0; i < n; i++) {',
      '    count[(arr[i] / place) % 10]++;',
      '  }',
      '',
      '  for (int i = 1; i < 10; i++) {',
      '    count[i] += count[i - 1];',
      '  }',
      '',
      '  for (int i = n - 1; i >= 0; i--) {',
      '    output[count[(arr[i] / place) % 10] - 1] = arr[i];',
      '    count[(arr[i] / place) % 10]--;',
      '  }',
      '',
      '  for (int i = 0; i < n; i++) {',
      '    arr[i] = output[i];',
      '  }',
      '  free(output);',
      '}',
      '',
      'void radixSort(int arr[], int n) {',
      '  if (n == 0) return;',
      '  int maxVal = getMax(arr, n);',
      '  for (int place = 1; maxVal / place > 0; place *= 10) {',
      '    countingSortForRadix(arr, n, place);',
      '  }',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <algorithm> // For std::max_element',
      '#include <array> // For std::array count',
      '',
      'int getMaxCpp(const std::vector<int>& arr) {',
      '  if (arr.empty()) return 0; // Or handle appropriately',
      '  return *std::max_element(arr.begin(), arr.end());',
      '}',
      '',
      'void countingSortForRadixCpp(std::vector<int>& arr, int place) {',
      '  int n = arr.size();',
      '  if (n == 0) return;',
      '  std::vector<int> output(n);',
      '  std::array<int, 10> count = {0};',
      '',
      '  for (int i = 0; i < n; i++) {',
      '    count[(arr[i] / place) % 10]++; // Assumes arr[i] non-negative',
      '  }',
      '',
      '  for (int i = 1; i < 10; i++) {',
      '    count[i] += count[i - 1];',
      '  }',
      '',
      '  for (int i = n - 1; i >= 0; i--) {',
      '    output[count[(arr[i] / place) % 10] - 1] = arr[i];',
      '    count[(arr[i] / place) % 10]--;',
      '  }',
      '',
      '  for (int i = 0; i < n; i++) {',
      '    arr[i] = output[i];',
      '  }',
      '}',
      '',
      'void radixSort(std::vector<int>& arr) {',
      '  if (arr.empty()) return;',
      '  int maxVal = getMaxCpp(arr);',
      '  for (int place = 1; maxVal / place > 0; place *= 10) {',
      '    countingSortForRadixCpp(arr, place);',
      '  }',
      '}',
    ],
    python: [
      'def counting_sort_for_radix(arr, place):',
      '    n = len(arr)',
      '    output = [0] * n',
      '    count = [0] * 10',
      '',
      '    for i in range(n):',
      '        digit = (arr[i] // place) % 10 # Assumes arr[i] non-negative',
      '        count[digit] += 1',
      '',
      '    for i in range(1, 10):',
      '        count[i] += count[i - 1]',
      '',
      '    i = n - 1',
      '    while i >= 0:',
      '        digit = (arr[i] // place) % 10',
      '        output[count[digit] - 1] = arr[i]',
      '        count[digit] -= 1',
      '        i -= 1',
      '',
      '    for i in range(n):',
      '        arr[i] = output[i]',
      '',
      'def radix_sort(arr):',
      '    if not arr: # Handle empty list',
      '        return [] # Or arr based on desired behavior',
      '    max_val = 0',
      '    if arr: # Ensure arr is not empty before calling max()',
      '        max_val = max(arr) # For non-negatives, determines number of digits',
      '    place = 1',
      '    # The loop condition `max_val // place > 0` correctly handles max_val = 0',
      '    while max_val // place > 0:',
      '        counting_sort_for_radix(arr, place)',
      '        place *= 10',
      '    return arr',
    ],
  },
  hasAdvancedAuxiliaryVisuals: true,
}
