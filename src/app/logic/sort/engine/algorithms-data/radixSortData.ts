'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { radixSortGenerator } from '../algorithms'

const rawPlaintextPseudoCode = [
  'procedure radixSort(list)',
  '  maxVal = findMaxValue(list)',
  '  place = 1',
  '  while maxVal / place >= 1',
  '    countingSortByDigit(list, place)',
  '    place = place * 10',
  '  end while',
  'end procedure',
  '',
  'procedure countingSortByDigit(list, place)',
  '  n = length of list',
  '  output = array of size n',
  '  count = array of 10 zeros',
  '',
  '  for i = 0 to n - 1',
  '    digit = (list[i] / place) mod 10',
  '    count[digit] = count[digit] + 1',
  '  end for',
  '',
  '  for i = 1 to 9',
  '    count[i] = count[i] + count[i - 1]',
  '  end for',
  '',
  '  for i = n - 1 down to 0',
  '    digit = (list[i] / place) mod 10',
  '    outputIndex = count[digit] - 1',
  '    output[outputIndex] = list[i]',
  '    count[digit] = count[digit] - 1',
  '  end for',
  '',
  '  for i = 0 to n - 1',
  '    list[i] = output[i]',
  '  end for',
  'end procedure',
]

export const radixSortData: SortAlgorithm = {
  id: 'radixSort',
  name: 'Radix Sort',
  description:
    'Dating back to the work of Herman Hollerith in 1887 for tabulating machines, Radix Sort is a non-comparative sorting algorithm that sorts data with integer keys by grouping keys by individual digits which share the same significant position and value. It processes digits from either the least significant digit (LSD) or most significant digit (MSD). This approach avoids direct comparisons and can be very efficient for certain types of data, particularly when the range of key values is limited. The version described here is typically for non-negative integers; handling signed integers requires modifications (e.g., sorting by absolute values then handling signs, or processing negative numbers separately). For descending order, a common approach is to sort in ascending order and then reverse the resulting list.',
  generator: radixSortGenerator,
  complexity: { time: { best: 'O(nk)', average: 'O(nk)', worst: 'O(nk)' }, space: 'O(n + k)' },
  origin: { name: 'Herman Hollerith', year: 1887 },
  img: 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/42/Hollerith.jpg/250px-Hollerith.jpg',
  pseudoCode: rawPlaintextPseudoCode,
  languageExamples: {
    c: [
      '#include <stdlib.h>',
      '#include <stdbool.h>',
      '#include <string.h> // For memset',
      '',
      '// Function to get maximum value in arr[]',
      'int getMax(int arr[], int n) {',
      '    int mx = arr[0];',
      '    for (int i = 1; i < n; i++)',
      '        if (arr[i] > mx)',
      '            mx = arr[i];',
      '    return mx;',
      '}',
      '',
      '// A function to do counting sort of arr[] according to the digit represented by exp.',
      'void countSort(int arr[], int n, int exp, bool ascending /* Not used */) {',
      '    int* output = (int*)malloc(n * sizeof(int)); ',
      '    int count[10];',
      '    memset(count, 0, sizeof(count));',
      '',
      '    // Store count of occurrences in count[]',
      '    for (int i = 0; i < n; i++)',
      '        count[(arr[i] / exp) % 10]++;',
      '',
      '    // Change count[i] so that count[i] now contains actual position',
      '    for (int i = 1; i < 10; i++)',
      '        count[i] += count[i - 1];',
      '',
      '    // Build the output array',
      '    for (int i = n - 1; i >= 0; i--) {',
      '        output[count[(arr[i] / exp) % 10] - 1] = arr[i];',
      '        count[(arr[i] / exp) % 10]--;',
      '    }',
      '',
      '    // Copy the output array to arr[]',
      '    for (int i = 0; i < n; i++)',
      '        arr[i] = output[i];',
      '    free(output);',
      '}',
      '',
      'void radixSort(int arr[], int n, bool ascending) {',
      '    if (n <= 1) return;',
      '    int m = getMax(arr, n);',
      '    for (int exp = 1; m / exp > 0; exp *= 10)',
      '        countSort(arr, n, exp, ascending);',
      '',
      '    if (!ascending) {',
      '        for (int i = 0; i < n / 2; i++) {',
      '            int temp = arr[i];',
      '            arr[i] = arr[n - i - 1];',
      '            arr[n - i - 1] = temp;',
      '        }',
      '    }',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <algorithm> // For std::max_element, std::reverse',
      '',
      '// Function to get maximum value in arr[]',
      'template <typename T>',
      'T getMax(const std::vector<T>& arr) {',
      '    return *std::max_element(arr.begin(), arr.end());',
      '}',
      '',
      '// A function to do counting sort of arr[] according to the digit represented by exp.',
      'template <typename T>',
      'void countSort(std::vector<T>& arr, int exp, bool ascending /* Not used */) {',
      '    int n = arr.size();',
      '    std::vector<T> output(n);',
      '    std::vector<int> count(10, 0);',
      '',
      '    for (int i = 0; i < n; i++)',
      '        count[(arr[i] / exp) % 10]++;',
      '',
      '    for (int i = 1; i < 10; i++)',
      '        count[i] += count[i - 1];',
      '',
      '    for (int i = n - 1; i >= 0; i--) {',
      '        output[count[(arr[i] / exp) % 10] - 1] = arr[i];',
      '        count[(arr[i] / exp) % 10]--;',
      '    }',
      '',
      '    for (int i = 0; i < n; i++)',
      '        arr[i] = output[i];',
      '}',
      '',
      'template <typename T>',
      'void radixSort(std::vector<T>& arr, bool ascending) {',
      '    if (arr.empty() || arr.size() <= 1) return;',
      '    T m = getMax(arr);',
      '    for (int exp = 1; m / exp > 0; exp *= 10)',
      '        countSort(arr, exp, ascending);',
      '',
      '    if (!ascending) {',
      '        std::reverse(arr.begin(), arr.end());',
      '    }',
      '}',
    ],
    python: [
      'def counting_sort_by_digit(arr, exp, ascending): # ascending not used',
      '    n = len(arr)',
      '    output = [0] * n',
      '    count = [0] * 10',
      '',
      '    for i in range(n):',
      '        index = arr[i] // exp',
      '        count[index % 10] += 1',
      '',
      '    for i in range(1, 10):',
      '        count[i] += count[i - 1]',
      '',
      '    i = n - 1',
      '    while i >= 0:',
      '        index = arr[i] // exp',
      '        output[count[index % 10] - 1] = arr[i]',
      '        count[index % 10] -= 1',
      '        i -= 1',
      '',
      '    for i in range(len(arr)):',
      '        arr[i] = output[i]',
      '',
      'def radix_sort(arr, ascending=True):',
      '    if not arr or len(arr) <= 1:',
      '        return arr',
      '',
      '    max_val = max(arr)',
      '',
      '    exp = 1',
      '    while max_val // exp >= 1:',
      '        counting_sort_by_digit(arr, exp, ascending)',
      '        exp *= 10',
      '',
      '    if not ascending:',
      '        arr.reverse()',
      '',
      '    return arr',
    ],
  },
  pseudoCodeMapping: {
    0: { c: [41], cpp: [32], python: [23] },
    1: { c: [43], cpp: [34], python: [27] },
    2: { c: [44], cpp: [35], python: [29] },
    3: { c: [44], cpp: [35], python: [30] },
    4: { c: [45], cpp: [36], python: [31] },
    5: { c: [45], cpp: [36], python: [32] },
    6: { c: [44], cpp: [35], python: [30] },
    7: { c: [53], cpp: [39], python: [36] },
    8: { c: [14], cpp: [11], python: [1] },
    9: { c: [14], cpp: [12], python: [2] },
    10: { c: [15], cpp: [13], python: [3] },
    11: { c: [16, 17], cpp: [14], python: [4] },
    13: { c: [20], cpp: [17], python: [6] },
    14: { c: [21], cpp: [18], python: [7, 8] },
    15: { c: [21], cpp: [18], python: [8] },
    16: { c: [20], cpp: [17], python: [6] },
    18: { c: [25], cpp: [21], python: [10] },
    19: { c: [26], cpp: [22], python: [11] },
    20: { c: [25], cpp: [21], python: [10] },
    22: { c: [29], cpp: [25], python: [14] },
    23: { c: [30], cpp: [26], python: [15, 16] },
    24: { c: [30], cpp: [26], python: [16] },
    25: { c: [30], cpp: [26], python: [16] },
    26: { c: [31], cpp: [27], python: [17] },
    27: { c: [29], cpp: [25], python: [14] },
    29: { c: [35], cpp: [30], python: [20] },
    30: { c: [36], cpp: [31], python: [21] },
    31: { c: [38], cpp: [31], python: [20] },
    32: { c: [38], cpp: [31], python: [21] },
  },
  performancePaths: {
    best: [
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 18, 19, 20, 22, 23, 24, 25, 26, 27, 29,
      30, 31, 32,
    ],
    worst: [
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 18, 19, 20, 22, 23, 24, 25, 26, 27, 29,
      30, 31, 32,
    ],
    average: [
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 18, 19, 20, 22, 23, 24, 25, 26, 27, 29,
      30, 31, 32,
    ],
  },
  hasAdvancedAuxiliaryVisuals: true,
}
