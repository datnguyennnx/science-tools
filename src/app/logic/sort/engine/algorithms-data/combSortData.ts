'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { combSortGenerator } from '../algorithms'

export const combSortData: SortAlgorithm = {
  id: 'combSort',
  name: 'Comb Sort',
  description:
    'Comb Sort is an improvement over Bubble Sort. It eliminates "turtles" (small values near the end of the list that significantly slow down Bubble Sort) by using an initial large gap between compared elements. The gap shrinks with each pass using a "shrink factor" (typically 1.3). The process continues until the gap is 1, at which point Comb Sort effectively becomes a Bubble Sort to clean up remaining inversions. The algorithm terminates when a pass with gap 1 completes without any swaps.',
  generator: combSortGenerator,
  complexity: {
    time: { best: 'O(n log n)', average: 'O(n log n)', worst: 'O(n^2)' }, // Average often O(n log n), can be O(n^2) for non-ideal gaps
    space: 'O(1)',
  },
  origin: {
    name: 'WÅ‚odzimierz Dobosiewicz (1980), popularized by Stephen Lacey and Richard Box',
    year: 1991,
  },
  pseudoCodes: {
    plaintext: [
      'procedure combSort(list, direction)',
      '  n = length of list',
      '  gap = n',
      '  shrinkFactor = 1.3',
      '  swapped = true',
      '',
      '  while gap > 1 or swapped',
      '    gap = floor(gap / shrinkFactor)',
      '    if gap < 1 then',
      '      gap = 1',
      '    end if',
      '',
      '    swapped = false',
      '    for i = 0 to n - 1 - gap',
      '      if (direction == ASC and list[i] > list[i + gap]) or (direction == DESC and list[i] < list[i + gap]) then',
      '        swap(list[i], list[i + gap])',
      '        swapped = true',
      '      end if',
      '    end for',
      '',
      '    if gap == 1 and not swapped then',
      '      break',
      '    end if',
      '  end while',
      'end procedure',
    ],
    c: [
      '#include <stdbool.h>',
      '#include <math.h>',
      '',
      'typedef enum { ASC, DESC } SortDirection;',
      '',
      'void swap(int *xp, int *yp) {',
      '    int temp = *xp;',
      '    *xp = *yp;',
      '    *yp = temp;',
      '}',
      '',
      'int get_next_gap(int gap) {',
      '    gap = floor((double)gap / 1.3);',
      '    if (gap < 1) {',
      '        return 1;',
      '    }',
      '    return gap;',
      '}',
      '',
      'void combSort(int arr[], int n, SortDirection direction) {',
      '    if (n <= 1) return;',
      '    int gap = n;',
      '    bool swapped = true;',
      '',
      '    while (gap > 1 || swapped) {',
      '        gap = get_next_gap(gap);',
      '        swapped = false;',
      '',
      '        for (int i = 0; i <= n - 1 - gap; i++) {',
      '            bool conditionMet = false;',
      '            if (direction == ASC) {',
      '                if (arr[i] > arr[i + gap]) conditionMet = true;',
      '            } else {',
      '                if (arr[i] < arr[i + gap]) conditionMet = true;',
      '            }',
      '',
      '            if (conditionMet) {',
      '                swap(&arr[i], &arr[i + gap]);',
      '                swapped = true;',
      '            }',
      '        }',
      '',
      '        if (gap == 1 && !swapped) {',
      '            break;',
      '        }',
      '    }',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <algorithm>',
      '#include <cmath>',
      '',
      'enum class SortDirection { ASC, DESC };',
      '',
      'int getNextGap(int gap) {',
      '    gap = static_cast<int>(std::floor(static_cast<double>(gap) / 1.3));',
      '    if (gap < 1) {',
      '        return 1;',
      '    }',
      '    return gap;',
      '}',
      '',
      'void combSort(std::vector<int>& arr, SortDirection direction) {',
      '    int n = arr.size();',
      '    if (n <= 1) return;',
      '    int gap = n;',
      '    bool swapped = true;',
      '',
      '    while (gap > 1 || swapped) {',
      '        gap = getNextGap(gap);',
      '        swapped = false;',
      '',
      '        for (int i = 0; i <= n - 1 - gap; i++) {',
      '            bool conditionMet = false;',
      '            if (direction == SortDirection::ASC) {',
      '                if (arr[i] > arr[i + gap]) conditionMet = true;',
      '            } else {',
      '                if (arr[i] < arr[i + gap]) conditionMet = true;',
      '            }',
      '',
      '            if (conditionMet) {',
      '                std::swap(arr[i], arr[i + gap]);',
      '                swapped = true;',
      '            }',
      '        }',
      '',
      '        if (gap == 1 && !swapped) {',
      '            break;',
      '        }',
      '    }',
      '}',
    ],
    python: [
      'import math',
      '',
      'def get_next_gap(gap):',
      '    gap = math.floor(gap / 1.3)',
      '    if gap < 1:',
      '        return 1',
      '    return int(gap)',
      '',
      'def comb_sort(arr, direction="asc"):',
      '    n = len(arr)',
      '    if n <= 1:',
      '        return arr',
      '    gap = n',
      '    swapped = True',
      '',
      '    while gap > 1 or swapped:',
      '        gap = get_next_gap(gap)',
      '        swapped = False',
      '',
      '        for i in range(n - gap):',
      '            condition_met = False',
      '            if direction == "asc":',
      '                if arr[i] > arr[i + gap]:',
      '                    condition_met = True',
      '            else:',
      '                if arr[i] < arr[i + gap]:',
      '                    condition_met = True',
      '            ',
      '            if condition_met:',
      '                arr[i], arr[i + gap] = arr[i + gap], arr[i]',
      '                swapped = True',
      '',
      '        if gap == 1 and not swapped:',
      '            break',
      '    return arr',
    ],
  },
  pseudoCodeMapping: {
    0: { c: [18], cpp: [14], python: [8] },
    1: { c: [19], cpp: [15], python: [9] },
    2: { c: [20], cpp: [17], python: [12] },
    3: { c: [], cpp: [], python: [] },
    4: { c: [21], cpp: [18], python: [13] },
    5: { c: [], cpp: [], python: [] },
    6: { c: [23], cpp: [20], python: [15] },
    7: { c: [24], cpp: [21], python: [16] },
    8: { c: [13], cpp: [9], python: [4] },
    9: { c: [14], cpp: [10], python: [5] },
    10: { c: [16], cpp: [12], python: [6] },
    11: { c: [], cpp: [], python: [] },
    12: { c: [25], cpp: [22], python: [17] },
    13: { c: [27], cpp: [24], python: [19] },
    14: {
      c: [29, 30, 31, 32, 33],
      cpp: [26, 27, 28, 29, 30],
      python: [21, 22, 23, 24, 25, 26, 28],
    },
    15: { c: [35], cpp: [32], python: [29] },
    16: { c: [36], cpp: [33], python: [30] },
    17: { c: [37], cpp: [34], python: [30] },
    18: { c: [38], cpp: [35], python: [30] },
    19: { c: [], cpp: [], python: [] },
    20: { c: [40], cpp: [37], python: [32] },
    21: { c: [41], cpp: [38], python: [33] },
    22: { c: [42], cpp: [39], python: [33] },
    23: { c: [43], cpp: [40], python: [34] },
    24: { c: [44], cpp: [41], python: [34] },
  },
  hasAdvancedAuxiliaryVisuals: false,
}
