'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { combSortGenerator } from '../algorithms'

export const combSortData: SortAlgorithm = {
  id: 'combSort',
  name: 'Comb Sort',
  description:
    'Comb Sort is an improvement over Bubble Sort. It eliminates "turtles" (small values near the end of the list that significantly slow down Bubble Sort) by using an initial large gap between compared elements. The gap shrinks with each pass using a "shrink factor" (typically 1.3). The process continues until the gap is 1, at which point Comb Sort effectively becomes a Bubble Sort to clean up remaining inversions. The algorithm terminates when a pass with gap 1 completes without any swaps.',
  generator: combSortGenerator,
  complexity: {
    time: { best: 'O(n log n)', average: 'O(n log n)', worst: 'O(n^2)' }, // Average often O(n log n), can be O(n^2) for non-ideal gaps
    space: 'O(1)',
  },
  origin: {
    name: 'WÅ‚odzimierz Dobosiewicz (1980), popularized by Stephen Lacey and Richard Box',
    year: 1991,
  }, // Year refers to Byte magazine article
  // img: 'URL_to_comb_sort_image', // Placeholder
  pseudoCodes: {
    plaintext: [
      'procedure combSort(list)',
      '  n = length of list',
      '  gap = n',
      '  shrink = 1.3',
      '  swapped = true',
      '  while gap > 1 or swapped do',
      '    gap = floor(gap / shrink)',
      '    if gap < 1 then',
      '      gap = 1',
      '    end if',
      '    swapped = false',
      '    for i = 0 to n - 1 - gap',
      '      if list[i] > list[i + gap] then',
      '        swap(list[i], list[i + gap])',
      '        swapped = true',
      '      end if',
      '    end for',
      '  end while',
      'end procedure',
    ],
    c: [
      '#include <stdbool.h>',
      '#include <math.h> // For floor',
      '',
      'void swap(int* a, int* b) {',
      '  int temp = *a;',
      '  *a = *b;',
      '  *b = temp;',
      '}',
      '',
      'void combSort(int arr[], int n) {',
      '  int gap = n;',
      '  float shrink = 1.3f;',
      '  bool swapped = true;',
      '  while (gap > 1 || swapped) {',
      '    gap = floor((float)gap / shrink);',
      '    if (gap < 1) {',
      '      gap = 1;',
      '    }',
      '    swapped = false;',
      '    for (int i = 0; i + gap < n; i++) {',
      '      if (arr[i] > arr[i + gap]) {',
      '        swap(&arr[i], &arr[i + gap]);',
      '        swapped = true;',
      '      }',
      '    }',
      '  }',
      '}',
    ],
    cpp: [
      '#include <utility> // For std::swap',
      '#include <cmath>   // For std::floor',
      '',
      'void combSort(int arr[], int n) {',
      '  int gap = n;',
      '  double shrink = 1.3;',
      '  bool swapped = true;',
      '  while (gap > 1 || swapped) {',
      '    gap = static_cast<int>(std::floor(gap / shrink));',
      '    if (gap < 1) {',
      '      gap = 1;',
      '    }',
      '    swapped = false;',
      '    for (int i = 0; i + gap < n; i++) {',
      '      if (arr[i] > arr[i + gap]) {',
      '        std::swap(arr[i], arr[i + gap]);',
      '        swapped = true;',
      '      }',
      '    }',
      '  }',
      '}',
    ],
    python: [
      'import math',
      '',
      'def combSort(arr):',
      '  n = len(arr)',
      '  gap = n',
      '  shrink = 1.3',
      '  swapped = True',
      '  while gap > 1 or swapped:',
      '    gap = math.floor(gap / shrink)',
      '    if gap < 1:',
      '      gap = 1',
      '    swapped = False',
      '    for i in range(n - gap):',
      '      if arr[i] > arr[i + gap]:',
      '        arr[i], arr[i + gap] = arr[i + gap], arr[i]',
      '        swapped = True',
    ],
  },
}
