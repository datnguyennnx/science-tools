'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { shellSortGenerator, createShellSortGeneratorInternal } from '../algorithms'

const rawPlaintextPseudoCode = [
  'procedure shellSort(list, direction)',
  '  n = length of list',
  '  gap = n / 2',
  '  while gap > 0',
  '    for i = gap to n - 1',
  '      temp = list[i]',
  '      j = i',
  '      while j >= gap and ((direction == ASC and list[j - gap] > temp) or (direction == DESC and list[j - gap] < temp))',
  '        list[j] = list[j - gap]',
  '        j = j - gap',
  '      end while',
  '      list[j] = temp',
  '    end for',
  '    gap = gap / 2',
  '  end while',
  'end procedure',
]

export const shellSortData: SortAlgorithm = {
  id: 'shellSort',
  name: 'Shell Sort',
  description:
    'Shell Sort is an in-place comparison sort. It can be seen as either a generalization of sorting by exchange (bubble sort) or sorting by insertion (insertion sort). The method starts by sorting pairs of elements far apart from each other, then progressively reducing the gap between elements to be compared. Starting with far apart elements can move some out-of-place elements into position faster than a simple nearest neighbor exchange. Donald Shell published the first version of this sort in 1959. The running time of Shell sort is heavily dependent on the gap sequence it uses. For many practical variants, determining their time complexity remains an open problem.',
  generator: shellSortGenerator,
  complexity: {
    time: {
      best: 'O(n log n)',
      average: 'Varies with gap sequence (e.g., O(n log\u00b2 n) to O(n^(3/2)))',
      worst: 'O(n^2)',
    },
    space: 'O(1)',
  },
  origin: { name: 'Donald Shell', year: 1959 },
  img: 'https://upload.wikimedia.org/wikipedia/commons/0/05/DonShell-1.jpg',
  pseudoCode: rawPlaintextPseudoCode,
  languageExamples: {
    c: [
      '#include <stdbool.h>',
      '',
      'void shellSort(int arr[], int n, bool ascending) {',
      '    if (n <= 1) return;',
      '    for (int gap = n / 2; gap > 0; gap /= 2) {',
      '        for (int i = gap; i < n; i += 1) {',
      '            int temp = arr[i];',
      '            int j = i;',
      '            while (j >= gap && ((ascending && arr[j - gap] > temp) || (!ascending && arr[j - gap] < temp))) {',
      '                arr[j] = arr[j - gap];',
      '                j -= gap;',
      '            }',
      '            arr[j] = temp;',
      '        }',
      '    }',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '',
      'template <typename T>',
      'void shellSort(std::vector<T>& arr, bool ascending) {',
      '    int n = arr.size();',
      '    if (n <= 1) return;',
      '    for (int gap = n / 2; gap > 0; gap /= 2) {',
      '        for (int i = gap; i < n; i += 1) {',
      '            T temp = arr[i];',
      '            int j;',
      '            for (j = i; j >= gap; j -= gap) {',
      '                bool shouldBreak = false;',
      '                if (ascending) {',
      '                    if (arr[j - gap] <= temp) shouldBreak = true;',
      '                } else {',
      '                    if (arr[j - gap] >= temp) shouldBreak = true;',
      '                }',
      '                if (shouldBreak) break;',
      '                arr[j] = arr[j - gap];',
      '            }',
      '            arr[j] = temp;',
      '        }',
      '    }',
      '}',
    ],
    python: [
      'def shell_sort(arr, ascending=True):',
      '    n = len(arr)',
      '    if n <= 1:',
      '        return arr',
      '    gap = n // 2',
      '    while gap > 0:',
      '        for i in range(gap, n):',
      '            temp = arr[i]',
      '            j = i',
      '            condition = False',
      '            if ascending:',
      '                if j >= gap and arr[j - gap] > temp:',
      '                    condition = True',
      '            else:',
      '                if j >= gap and arr[j - gap] < temp:',
      '                    condition = True',
      '            ',
      '            while condition:',
      '                arr[j] = arr[j - gap]',
      '                j -= gap',
      '                if ascending:',
      '                    if j >= gap and arr[j - gap] > temp:',
      '                        condition = True',
      '                    else:',
      '                        condition = False',
      '                else:',
      '                    if j >= gap and arr[j - gap] < temp:',
      '                        condition = True',
      '                    else:',
      '                        condition = False',
      '            arr[j] = temp',
      '        gap //= 2',
      '    return arr',
    ],
  },
  pseudoCodeMapping: {
    0: { c: [3], cpp: [4], python: [1] },
    1: { c: [4], cpp: [6], python: [2] },
    2: { c: [5], cpp: [8], python: [5] },
    3: { c: [5], cpp: [8], python: [6] },
    4: { c: [6], cpp: [9], python: [7] },
    5: { c: [7], cpp: [10], python: [8] },
    6: { c: [8], cpp: [11], python: [9] },
    7: { c: [9], cpp: [12, 13, 14, 15, 16, 17, 18], python: [10, 11, 12, 13, 14, 15, 17] },
    8: { c: [10], cpp: [19], python: [18] },
    9: { c: [11], cpp: [12], python: [19] },
    10: { c: [9], cpp: [12], python: [17] },
    11: { c: [13], cpp: [21], python: [28] },
    12: { c: [6], cpp: [9], python: [7] },
    13: { c: [5], cpp: [8], python: [29] },
    14: { c: [5], cpp: [8], python: [6] },
    15: { c: [16], cpp: [24], python: [30] },
  },
  performancePaths: {
    best: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
    worst: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
    average: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
  },
  hasAdvancedAuxiliaryVisuals: false,
}

export const shellSortVariations: SortAlgorithm[] = [
  {
    id: 'shellSortHabermann',
    name: 'Shell Sort (Habermann)',
    description:
      "A variation of Shell Sort using N. Habermann's gap sequence: \\(h_k = 2^k - 1\\). This sequence, while simple, can lead to poor performance in some cases, particularly when the number of elements is a power of 2.",
    generator: (initialArray: number[], direction: 'asc' | 'desc') =>
      createShellSortGeneratorInternal(initialArray, direction, 'habermann'),
    complexity: {
      time: {
        best: 'O(n log n)',
        average: 'Varies',
        worst: 'O(n^2)',
      },
      space: 'O(1)',
    },
    origin: { name: 'N. Habermann', year: 1972 },
    img: '',
    pseudoCode: rawPlaintextPseudoCode,
  },
  {
    id: 'shellSortSedgewick',
    name: 'Shell Sort (Sedgewick)',
    description:
      "A variation of Shell Sort using Robert Sedgewick's gap sequence: \\(h_k = 4^k + 3 \\cdot 2^{k-1} + 1\\). This sequence generally provides better performance than Shell's original sequence or Habermann's sequence.",
    generator: (initialArray: number[], direction: 'asc' | 'desc') =>
      createShellSortGeneratorInternal(initialArray, direction, 'sedgewick'),
    complexity: {
      time: {
        best: 'O(n log n)',
        average: 'O(n^(4/3))',
        worst: 'O(n^(4/3))',
      },
      space: 'O(1)',
    },
    origin: { name: 'Robert Sedgewick', year: 1982 },
    img: '/images/sort/robert-sedgewick.jpg',
    pseudoCode: rawPlaintextPseudoCode,
  },
  {
    id: 'shellSortPratt',
    name: 'Shell Sort (Pratt)',
    description:
      "A variation of Shell Sort using Vaughan Pratt's gap sequence, which consists of all numbers of the form \\(2^i 3^j\\). This sequence leads to a time complexity of \\(O(n \\log^2 n)\\), which is asymptotically optimal for Shell Sort.",
    generator: (initialArray: number[], direction: 'asc' | 'desc') =>
      createShellSortGeneratorInternal(initialArray, direction, 'pratt'),
    complexity: {
      time: {
        best: 'O(n log n)',
        average: 'O(n log\u00b2 n)',
        worst: 'O(n log\u00b2 n)',
      },
      space: 'O(1)',
    },
    origin: { name: 'Vaughan Pratt', year: 1971 },
    img: '/images/sort/vaughan-pratt.jpg',
    pseudoCode: rawPlaintextPseudoCode,
  },
  {
    id: 'shellSortCiura',
    name: 'Shell Sort (Ciura)',
    description:
      "A variation of Shell Sort using Marcin Ciura's empirically derived gap sequence: [1, 4, 10, 23, 57, 132, 301, 701, 1750]. This sequence is considered one of the best performing for arrays up to a few thousand elements.",
    generator: (initialArray: number[], direction: 'asc' | 'desc') =>
      createShellSortGeneratorInternal(initialArray, direction, 'ciura'),
    complexity: {
      time: {
        best: 'O(n log n)',
        average: 'Empirically O(n log n) to O(n log\u00b2 n)',
        worst: 'Unknown, conjectured O(n log\u00b2 n)',
      },
      space: 'O(1)',
    },
    origin: { name: 'Marcin Ciura', year: 2001 },
    img: '/images/sort/marcin-ciura.jpg',
    pseudoCode: rawPlaintextPseudoCode,
  },
]
