'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { pancakeSortGenerator } from '../algorithms'

export const pancakeSortData: SortAlgorithm = {
  id: 'pancakeSort',
  name: 'Pancake Sort',
  description:
    'Pancake Sort is a whimsical sorting problem and algorithm where the only allowed operation is to reverse the order of the top k elements of a stack (a "spatula flip"). The goal is to sort a stack of pancakes (elements of an array) by size using the minimum number of flips. First seriously studied by computer scientist and mathematician Jacob E. Goodman (under the pseudonym "Harry Dweighter"), it gained further recognition when Bill Gates co-authored a paper on it. The algorithm focuses on minimizing flips rather than comparisons.',
  generator: pancakeSortGenerator,
  complexity: { time: { best: 'O(n)', average: 'O(n^2)', worst: 'O(n^2)' }, space: 'O(1)' },
  origin: { name: 'Jacob E. Goodman', year: 1975 },
  img: 'https://www.navonarecords.com/nv/wp-content/uploads/2022/01/Jacob-Goodman.jpg',
  pseudoCodes: {
    plaintext: [
      'procedure pancakeSort(list)',
      '  n = length of list',
      '  for currentSize = n down to 2',
      '    maxIndex = findMaxIndex(list, currentSize) // For ascending sort. For descending, findMinIndex',
      '    if maxIndex != currentSize - 1 then',
      '      if maxIndex != 0 then',
      '        flip(list, maxIndex + 1)',
      '      end if',
      '      flip(list, currentSize)',
      '    end if',
      '  end for',
      'end procedure',
      '',
      'procedure findMaxIndex(list, size) // Finds index of maximum for ascending sort',
      '  indexOfExtreme = 0 // Stores index of max (for asc) or min (for desc)',
      '  for i = 1 to size - 1',
      '    // For ascending sort: list[i] > list[indexOfExtreme]',
      '    // For descending sort: list[i] < list[indexOfExtreme]',
      '    if list[i] > list[indexOfExtreme] then // Defaulting to ascending (find max)',
      '      indexOfExtreme = i',
      '    end if',
      '  end for',
      '  return indexOfExtreme',
      'end procedure',
      '',
      'procedure flip(list, k_elements)',
      '  start = 0',
      '  end = k_elements - 1',
      '  while start < end',
      '    swap(list[start], list[end])',
      '    start = start + 1',
      '    end = end - 1',
      '  end while',
      'end procedure',
    ],
    c: [
      'void swap(int* a, int* b) {',
      '  int temp = *a;',
      '  *a = *b;',
      '  *b = temp;',
      '}',
      '',
      'void flip(int arr[], int k_elements) {',
      '  int start = 0;',
      '  int end = k_elements - 1;',
      '  while (start < end) {',
      '    swap(&arr[start], &arr[end]);',
      '    start++;',
      '    end--;',
      '  }',
      '}',
      '',
      'int findMaxIndex(int arr[], int size) {',
      '  int maxIdx = 0; // For ascending sort. For descending, this would be minIdx.',
      '  for (int i = 1; i < size; i++) {',
      '    // For ascending sort: arr[i] > arr[maxIdx]',
      '    // For descending sort: arr[i] < arr[minIdx] (if maxIdx was renamed to minIdx)',
      '    if (arr[i] > arr[maxIdx]) { // Defaulting to ascending (find max)',
      '      maxIdx = i;',
      '    }',
      '  }',
      '  return maxIdx;',
      '}',
      '',
      'void pancakeSort(int arr[], int n) {',
      '  for (int currentSize = n; currentSize > 1; currentSize--) {',
      '    int maxIdx = findMaxIndex(arr, currentSize);',
      '    if (maxIdx != currentSize - 1) {',
      '      if (maxIdx != 0) {',
      '        flip(arr, maxIdx + 1);',
      '      }',
      '      flip(arr, currentSize);',
      '    }',
      '  }',
      '}',
    ],
    cpp: [
      '#include <utility> // For std::swap',
      '',
      'void flip(int arr[], int k_elements) {',
      '  int start = 0;',
      '  int end = k_elements - 1;',
      '  while (start < end) {',
      '    std::swap(arr[start], arr[end]);',
      '    start++;',
      '    end--;',
      '  }',
      '}',
      '',
      'int findMaxIndex(int arr[], int size) {',
      '  int maxIdx = 0; // For ascending sort. For descending, this would be minIdx.',
      '  for (int i = 1; i < size; i++) {',
      '    // For ascending sort: arr[i] > arr[maxIdx]',
      '    // For descending sort: arr[i] < arr[minIdx] (if maxIdx was renamed to minIdx)',
      '    if (arr[i] > arr[maxIdx]) { // Defaulting to ascending (find max)',
      '      maxIdx = i;',
      '    }',
      '  }',
      '  return maxIdx;',
      '}',
      '',
      'void pancakeSort(int arr[], int n) {',
      '  for (int currentSize = n; currentSize > 1; currentSize--) {',
      '    int maxIdx = findMaxIndex(arr, currentSize);',
      '    if (maxIdx != currentSize - 1) {',
      '      if (maxIdx != 0) {',
      '        flip(arr, maxIdx + 1);',
      '      }',
      '      flip(arr, currentSize);',
      '    }',
      '  }',
      '}',
    ],
    python: [
      'def flip(arr, k_elements):',
      '  left = 0',
      '  right = k_elements - 1',
      '  while left < right:',
      '    arr[left], arr[right] = arr[right], arr[left]',
      '    left += 1',
      '    right -= 1',
      '',
      'def findMaxIndex(arr, size):',
      '  max_idx = 0 # For ascending sort. For descending, this would be min_idx.',
      '  for i in range(1, size):',
      '    # For ascending sort: arr[i] > arr[max_idx]',
      '    # For descending sort: arr[i] < arr[min_idx] (if max_idx was renamed to min_idx)',
      '    if arr[i] > arr[max_idx]: # Defaulting to ascending (find max)',
      '      max_idx = i',
      '  return max_idx',
      '',
      'def pancakeSort(arr):',
      '  n = len(arr)',
      '  current_size = n',
      '  while current_size > 1:',
      '    max_idx = findMaxIndex(arr, current_size)',
      '    if max_idx != current_size - 1:',
      '      if max_idx != 0:',
      '        flip(arr, max_idx + 1)',
      '      flip(arr, current_size)',
      '    current_size -= 1',
    ],
  },
  hasAdvancedAuxiliaryVisuals: false,
}
