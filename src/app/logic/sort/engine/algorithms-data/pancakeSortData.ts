'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { pancakeSortGenerator } from '../algorithms'

export const pancakeSortData: SortAlgorithm = {
  id: 'pancakeSort',
  name: 'Pancake Sort',
  description:
    'Pancake Sort is a whimsical sorting problem and algorithm where the only allowed operation is to reverse the order of the top k elements of a stack (a "spatula flip"). The goal is to sort a stack of pancakes (elements of an array) by size using the minimum number of flips. First seriously studied by computer scientist and mathematician Jacob E. Goodman (under the pseudonym "Harry Dweighter"), it gained further recognition when Bill Gates co-authored a paper on it. The algorithm focuses on minimizing flips rather than comparisons.',
  generator: pancakeSortGenerator,
  complexity: { time: { best: 'O(n)', average: 'O(n^2)', worst: 'O(n^2)' }, space: 'O(1)' },
  origin: { name: 'Jacob E. Goodman', year: 1975 },
  img: 'https://www.navonarecords.com/nv/wp-content/uploads/2022/01/Jacob-Goodman.jpg',
  pseudoCodes: {
    plaintext: [
      'procedure pancakeSort(list, direction)',
      '  n = length of list',
      '  if n <= 1 then return list',
      '  for currentSize = n down to 2',
      '    extremeIndex = findExtremeIndex(list, currentSize, direction)',
      '    if extremeIndex != currentSize - 1 then',
      '      if extremeIndex != 0 then',
      '        flip(list, extremeIndex + 1)',
      '      end if',
      '      flip(list, currentSize)',
      '    end if',
      '  end for',
      '  return list',
      'end procedure',
      '',
      'procedure findExtremeIndex(list, size, direction)',
      '  idxOfExtreme = 0',
      '  for i = 1 to size - 1',
      '    isMoreExtreme = false',
      '    if direction == ASC then',
      '      isMoreExtreme = list[i] > list[idxOfExtreme]',
      '    else',
      '      isMoreExtreme = list[i] < list[idxOfExtreme]',
      '    end if',
      '    if isMoreExtreme then',
      '      idxOfExtreme = i',
      '    end if',
      '  end for',
      '  return idxOfExtreme',
      'end procedure',
      '',
      'procedure flip(list, k_elements)',
      '  start = 0',
      '  end = k_elements - 1',
      '  while start < end',
      '    swap(list[start], list[end])',
      '    start = start + 1',
      '    end = end - 1',
      '  end while',
      'end procedure',
    ],
    c: [
      '#include <stdbool.h>',
      '',
      'typedef enum { ASC, DESC } SortDirection;',
      '',
      'void swap(int* a, int* b) {',
      '    int temp = *a;',
      '    *a = *b;',
      '    *b = temp;',
      '}',
      '',
      'void flip(int arr[], int k) {',
      '    int start = 0;',
      '    int end = k - 1;',
      '    while (start < end) {',
      '        swap(&arr[start], &arr[end]);',
      '        start++;',
      '        end--;',
      '    }',
      '}',
      '',
      'int findExtremeIndex(int arr[], int size, SortDirection direction) {',
      '    int extremeIdx = 0;',
      '    for (int i = 1; i < size; i++) {',
      '        bool isMoreExtreme = false;',
      '        if (direction == ASC) {',
      '            if (arr[i] > arr[extremeIdx]) isMoreExtreme = true;',
      '        } else { ',
      '            if (arr[i] < arr[extremeIdx]) isMoreExtreme = true;',
      '        }',
      '        if (isMoreExtreme) {',
      '            extremeIdx = i;',
      '        }',
      '    }',
      '    return extremeIdx;',
      '}',
      '',
      'void pancakeSort(int arr[], int n, SortDirection direction) {',
      '    if (n <= 1) return;',
      '    for (int currentSize = n; currentSize > 1; currentSize--) {',
      '        int extremeIdx = findExtremeIndex(arr, currentSize, direction);',
      '        if (extremeIdx != currentSize - 1) {',
      '            if (extremeIdx != 0) {',
      '                flip(arr, extremeIdx + 1);',
      '            }',
      '            flip(arr, currentSize);',
      '        }',
      '    }',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <algorithm>',
      '',
      'enum class SortDirection { ASC, DESC };',
      '',
      'void flip(std::vector<int>& arr, int k) {',
      '    int start = 0;',
      '    int end = k - 1;',
      '    while (start < end) {',
      '        std::swap(arr[start], arr[end]);',
      '        start++;',
      '        end--;',
      '    }',
      '}',
      '',
      'int findExtremeIndex(const std::vector<int>& arr, int size, SortDirection direction) {',
      '    int extremeIdx = 0;',
      '    for (int i = 1; i < size; i++) {',
      '        bool isMoreExtreme = false;',
      '        if (direction == SortDirection::ASC) {',
      '            if (arr[i] > arr[extremeIdx]) isMoreExtreme = true;',
      '        } else {',
      '            if (arr[i] < arr[extremeIdx]) isMoreExtreme = true;',
      '        }',
      '        if (isMoreExtreme) {',
      '            extremeIdx = i;',
      '        }',
      '    }',
      '    return extremeIdx;',
      '}',
      '',
      'void pancakeSort(std::vector<int>& arr, SortDirection direction) {',
      '    int n = arr.size();',
      '    if (n <= 1) return;',
      '    for (int currentSize = n; currentSize > 1; currentSize--) {',
      '        int extremeIdx = findExtremeIndex(arr, currentSize, direction);',
      '        if (extremeIdx != currentSize - 1) {',
      '            if (extremeIdx != 0) {',
      '                flip(arr, extremeIdx + 1);',
      '            }',
      '            flip(arr, currentSize);',
      '        }',
      '    }',
      '}',
    ],
    python: [
      'def flip(arr, k):',
      '  start = 0',
      '  end = k - 1',
      '  while start < end:',
      '    arr[start], arr[end] = arr[end], arr[start]',
      '    start += 1',
      '    end -= 1',
      '',
      'def find_extreme_index(arr, size, direction="asc"):',
      '  extreme_idx = 0',
      '  for i in range(1, size):',
      '    is_more_extreme = False',
      '    if direction == "asc":',
      '      if arr[i] > arr[extreme_idx]:',
      '        is_more_extreme = True',
      '    else:',
      '      if arr[i] < arr[extreme_idx]:',
      '        is_more_extreme = True',
      '    if is_more_extreme:',
      '      extreme_idx = i',
      '  return extreme_idx',
      '',
      'def pancake_sort(arr, direction="asc"):',
      '  n = len(arr)',
      '  if n <= 1:',
      '    return arr',
      '  current_size = n',
      '  while current_size > 1:',
      '    extreme_idx = find_extreme_index(arr, current_size, direction)',
      '    if extreme_idx != current_size - 1:',
      '      if extreme_idx != 0:',
      '        flip(arr, extreme_idx + 1)',
      '      flip(arr, current_size)',
      '    current_size -= 1',
      '  return arr',
    ],
  },
  pseudoCodeMapping: {
    0: { c: [34], cpp: [30], python: [22] },
    1: { c: [35], cpp: [31], python: [23] },
    2: { c: [35], cpp: [32], python: [24, 25] },
    3: { c: [36], cpp: [33], python: [26, 27] },
    4: { c: [37], cpp: [34], python: [28] },
    5: { c: [38], cpp: [35], python: [29] },
    6: { c: [39], cpp: [36], python: [30] },
    7: { c: [40], cpp: [37], python: [31] },
    8: { c: [41], cpp: [38] },
    9: { c: [42], cpp: [39], python: [32] },
    10: { c: [43], cpp: [40] },
    11: { c: [44], cpp: [41], python: [33] },
    12: { python: [34] },
    13: { c: [45], cpp: [42], python: [34] },
    15: { c: [20], cpp: [15], python: [8] },
    16: { c: [21], cpp: [16], python: [9] },
    17: { c: [22], cpp: [17], python: [10] },
    18: { c: [23], cpp: [18], python: [11] },
    19: { c: [24], cpp: [19], python: [12] },
    20: { c: [25], cpp: [20], python: [13, 14] },
    21: { c: [26], cpp: [21], python: [15] },
    22: { c: [27], cpp: [22], python: [16, 17] },
    23: {},
    24: { c: [29], cpp: [24], python: [18] },
    25: { c: [30], cpp: [25], python: [19] },
    26: {},
    27: {},
    28: { c: [32], cpp: [27], python: [20] },
    29: { c: [33], cpp: [28], python: [20] },
    31: { c: [10], cpp: [5], python: [0] },
    32: { c: [11], cpp: [6], python: [1] },
    33: { c: [12], cpp: [7], python: [2] },
    34: { c: [13], cpp: [8], python: [3] },
    35: { c: [14], cpp: [9], python: [4] },
    36: { c: [15], cpp: [10], python: [5] },
    37: {},
    38: {},
    39: { c: [18], cpp: [13], python: [6] },
  },
  hasAdvancedAuxiliaryVisuals: false,
}
