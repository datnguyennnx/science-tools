import type { SortAlgorithm } from '../algorithmRegistry'

const rawPlaintextPseudoCode = [
  'procedure pancakeSort(list, direction)',
  '  n = length of list',
  '  for currentSize = n down to 2',
  '    maxIndex = findMaxElementIndex(list, currentSize)',
  '    if maxIndex != currentSize - 1 then',
  '      flip(list, maxIndex + 1)',
  '      flip(list, currentSize)',
  '    end if',
  '  end for',
  '  if direction is DESC then reverseEntireList(list) ',
  'end procedure',
  '',
  'procedure findMaxElementIndex(list, size)',
  '  maxIdx = 0',
  '  for i = 1 to size - 1',
  '    if list[i] > list[maxIdx] then',
  '      maxIdx = i',
  '    end if',
  '  end for',
  '  return maxIdx',
  'end procedure',
  '',
  'procedure flip(list, k)',
  '  left = 0',
  '  while left < k - 1',
  '    swap(list[left], list[k - 1])',
  '    left = left + 1',
  '    k = k - 1',
  '  end while',
  'end procedure',
]

export const pancakeSortData: SortAlgorithm = {
  id: 'pancakeSort',
  name: 'Pancake Sort',
  description:
    "Pancake Sort is a sorting algorithm that works by repeatedly finding the largest unsorted element and flipping it to the top of the unsorted portion of the list, then flipping the entire unsorted portion to move that element to its correct final position. The only allowed operation is flipping a prefix of the list. It's named after the problem of sorting a stack of pancakes of different sizes.",
  complexity: { time: { best: 'O(n)', average: 'O(n^2)', worst: 'O(n^2)' }, space: 'O(1)' },
  origin: { name: 'Jerome K. "Bill" Gates (as Harry Dweighter)', year: 1979 },
  img: '',
  pseudoCode: rawPlaintextPseudoCode,
  languageExamples: {
    c: [
      '#include <stdbool.h>',
      '',
      'void flip(int arr[], int i) {',
      '    int temp, start = 0;',
      '    while (start < i) {',
      '        temp = arr[start];',
      '        arr[start] = arr[i];',
      '        arr[i] = temp;',
      '        start++;',
      '        i--;',
      '    }',
      '}',
      '',
      'int findMaxIndex(int arr[], int n, bool ascending) {',
      '    int mi = 0;',
      '    for (int i = 0; i < n; ++i) {',
      '        if (ascending) {',
      '            if (arr[i] > arr[mi])',
      '                mi = i;',
      '        } else { // Descending',
      '            if (arr[i] < arr[mi])',
      '                mi = i;',
      '        }',
      '    }',
      '    return mi;',
      '}',
      '',
      'void pancakeSort(int arr[], int n, bool ascending) {',
      '    if (n <= 1) return;',
      '    for (int curr_size = n; curr_size > 1; --curr_size) {',
      '        int mi = findMaxIndex(arr, curr_size, ascending);',
      '',
      '        if (mi != curr_size - 1) {',
      '            if (mi != 0)',
      '                flip(arr, mi);',
      '',
      '            flip(arr, curr_size - 1);',
      '        }',
      '    }',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <algorithm> // For std::reverse, std::max_element/min_element',
      '',
      '// Helper to reverse arr[0..i]',
      'template <typename T>',
      'void flip(std::vector<T>& arr, int i) {',
      '    std::reverse(arr.begin(), arr.begin() + i + 1);',
      '}',
      '',
      '// Returns index of the extreme (max for asc, min for desc) element in arr[0..n-1]',
      'template <typename T>',
      'int findExtremeIndex(const std::vector<T>& arr, int n, bool ascending) {',
      '    if (n <= 0) return -1; // Should not happen if curr_size > 1',
      '    int extremeIdx = 0;',
      '    for (int i = 1; i < n; ++i) {',
      '        if (ascending) {',
      '            if (arr[i] > arr[extremeIdx]) {',
      '                extremeIdx = i;',
      '            }',
      '        } else { // Descending',
      '            if (arr[i] < arr[extremeIdx]) {',
      '                extremeIdx = i;',
      '            }',
      '        }',
      '    }',
      '    return extremeIdx;',
      '}',
      '',
      'template <typename T>',
      'void pancakeSort(std::vector<T>& arr, bool ascending) {',
      '    int n = arr.size();',
      '    if (n <= 1) return;',
      '',
      '    for (int curr_size = n; curr_size > 1; --curr_size) {',
      '        int extremeIdx = findExtremeIndex(arr, curr_size, ascending);',
      '',
      '        if (extremeIdx != curr_size - 1) {',
      '            if (extremeIdx != 0) {',
      '                flip(arr, extremeIdx);',
      '            }',
      '            flip(arr, curr_size - 1);',
      '        }',
      '    }',
      '}',
    ],
    python: [
      'def flip(arr, k):',
      '    """Reverses arr[0...k]."""',
      '    left = 0',
      '    while left < k:',
      '        arr[left], arr[k] = arr[k], arr[left]',
      '        left += 1',
      '        k -= 1',
      '',
      'def find_extreme_index(arr, n, ascending=True):',
      '    """Finds extreme (max/min) in arr[:n]."""',
      '    extreme_idx = 0',
      '    for i in range(1, n):',
      '        if ascending:',
      '            if arr[i] > arr[extreme_idx]:',
      '                extreme_idx = i',
      '        else: # descending',
      '            if arr[i] < arr[extreme_idx]:',
      '                extreme_idx = i',
      '    return extreme_idx',
      '',
      'def pancake_sort(arr, ascending=True):',
      '    n = len(arr)',
      '    if n <= 1:',
      '        return arr',
      '        ',
      '    for curr_size in range(n, 1, -1):',
      '        extreme_idx = find_extreme_index(arr, curr_size, ascending)',
      '',
      '        if extreme_idx != curr_size - 1:',
      '            if extreme_idx != 0:',
      '                flip(arr, extreme_idx)',
      '            ',
      '            flip(arr, curr_size - 1)',
      '    return arr',
    ],
  },
  pseudoCodeMapping: {
    0: { c: [30], cpp: [28], python: [22] },
    1: { c: [31], cpp: [29], python: [23] },
    2: { c: [33], cpp: [32], python: [27] },
    3: { c: [35], cpp: [33], python: [30] },
    4: { c: [38], cpp: [35], python: [33] },
    5: { c: [41], cpp: [37], python: [36] },
    6: { c: [44], cpp: [39], python: [40] },
    7: { c: [45], cpp: [40], python: [40] },
    8: { c: [46], cpp: [41], python: [40] },
    10: { c: [47], cpp: [42], python: [41] },
    12: { c: [16], cpp: [11], python: [10] },
    13: { c: [17], cpp: [13], python: [13] },
    14: { c: [18], cpp: [14], python: [14] },
    15: {
      c: [19, 20, 21, 22, 23, 24],
      cpp: [15, 16, 17, 18, 19, 20, 21],
      python: [15, 16, 17, 18, 19, 20],
    },
    16: { c: [21, 24], cpp: [17, 20], python: [17, 20] },
    17: { c: [21, 24], cpp: [17, 20], python: [17, 20] },
    18: { c: [25], cpp: [22], python: [20] },
    19: { c: [26], cpp: [23], python: [21] },
    21: { c: [3], cpp: [6], python: [1] },
    22: { c: [4], cpp: [7], python: [3] },
    23: { c: [5], cpp: [7], python: [4] },
    24: { c: [6, 7, 8], cpp: [7], python: [5] },
    25: { c: [9], cpp: [7], python: [6] },
    26: { c: [10], cpp: [7], python: [7] },
    27: { c: [5], cpp: [7], python: [4] },
    28: { c: [12], cpp: [8], python: [7] },
  },
  performancePaths: {
    best: [0, 1, 2, 3, 4, 7, 8, 10, 12, 13, 14, 18, 19],
    worst: [
      0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 13, 14, 15, 16, 17, 18, 19, 21, 22, 23, 24, 25, 26, 27, 28,
    ],
    average: [
      0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 13, 14, 15, 16, 17, 18, 19, 21, 22, 23, 24, 25, 26, 27, 28,
    ],
  },
}
