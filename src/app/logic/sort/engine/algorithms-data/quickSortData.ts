'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { quickSortGenerator } from '../algorithms'

const rawPlaintextPseudoCode = [
  'procedure quickSort(list, direction)',
  '  _quickSortRecursive(list, 0, length of list - 1, direction)',
  'end procedure',
  '',
  'procedure _quickSortRecursive(list, low, high, direction)',
  '  if low < high then',
  '    pivotIndex = _partition(list, low, high, direction)',
  '    _quickSortRecursive(list, low, pivotIndex - 1, direction)',
  '    _quickSortRecursive(list, pivotIndex + 1, high, direction)',
  '  end if',
  'end procedure',
  '',
  'procedure _partition(list, low, high, direction)',
  '  pivot = list[high]',
  '  i = low - 1',
  '  for j = low to high - 1',
  '    if (direction == ASC and list[j] < pivot) or (direction == DESC and list[j] > pivot) then',
  '      i = i + 1',
  '      swap(list[i], list[j])',
  '    end if',
  '  end for',
  '  swap(list[i + 1], list[high])',
  '  return i + 1',
  'end procedure',
]

export const quickSortData: SortAlgorithm = {
  id: 'quickSort',
  name: 'Quick Sort',
  description:
    "Developed by Tony Hoare in 1959, Quick Sort is an efficient, comparison-based, divide-and-conquer sorting algorithm. It works by selecting a 'pivot' element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then sorted recursively. While its worst-case performance is O(n^2), its average-case performance is O(n log n), making it one of the fastest sorting algorithms in practice.",
  generator: quickSortGenerator,
  complexity: {
    time: { best: 'O(n log n)', average: 'O(n log n)', worst: 'O(n^2)' },
    space: 'O(log n)',
  },
  origin: { name: 'Tony Hoare', year: 1959 },
  img: 'https://upload.wikimedia.org/wikipedia/commons/2/21/Tony_Hoare_MMBio_2010.jpg',
  pseudoCode: rawPlaintextPseudoCode,
  languageExamples: {
    c: [
      '#include <stdbool.h>',
      '',
      'void swap(int* a, int* b) {',
      '    int t = *a;',
      '    *a = *b;',
      '    *b = t;',
      '}',
      '',
      'int partition(int arr[], int low, int high, bool ascending) {',
      '    int pivot = arr[high];',
      '    int i = (low - 1);',
      '    for (int j = low; j <= high - 1; j++) {',
      '        bool shouldSwap;',
      '        if (ascending) {',
      '            shouldSwap = (arr[j] <= pivot);',
      '        } else {',
      '            shouldSwap = (arr[j] >= pivot);',
      '        }',
      '        if (shouldSwap) {',
      '            i++;',
      '            swap(&arr[i], &arr[j]);',
      '        }',
      '    }',
      '    swap(&arr[i + 1], &arr[high]);',
      '    return (i + 1);',
      '}',
      '',
      'void quickSortRecursive(int arr[], int low, int high, bool ascending) {',
      '    if (low < high) {',
      '        int pi = partition(arr, low, high, ascending);',
      '        quickSortRecursive(arr, low, pi - 1, ascending);',
      '        quickSortRecursive(arr, pi + 1, high, ascending);',
      '    }',
      '}',
      '',
      'void quickSort(int arr[], int n, bool ascending) {',
      '    if (n <=1) return;',
      '    quickSortRecursive(arr, 0, n - 1, ascending);',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <utility> // For std::swap',
      '',
      'template <typename T>',
      'int partition(std::vector<T>& arr, int low, int high, bool ascending) {',
      '    T pivot = arr[high];',
      '    int i = (low - 1);',
      '    for (int j = low; j <= high - 1; j++) {',
      '        bool shouldSwap;',
      '        if (ascending) {',
      '            shouldSwap = (arr[j] <= pivot);',
      '        } else {',
      '            shouldSwap = (arr[j] >= pivot);',
      '        }',
      '        if (shouldSwap) {',
      '            i++;',
      '            std::swap(arr[i], arr[j]);',
      '        }',
      '    }',
      '    std::swap(arr[i + 1], arr[high]);',
      '    return (i + 1);',
      '}',
      '',
      'template <typename T>',
      'void quickSortRecursive(std::vector<T>& arr, int low, int high, bool ascending) {',
      '    if (low < high) {',
      '        int pi = partition(arr, low, high, ascending);',
      '        quickSortRecursive(arr, low, pi - 1, ascending);',
      '        quickSortRecursive(arr, pi + 1, high, ascending);',
      '    }',
      '}',
      '',
      'template <typename T>',
      'void quickSort(std::vector<T>& arr, bool ascending) {',
      '    if (arr.size() <= 1) return;',
      '    quickSortRecursive(arr, 0, arr.size() - 1, ascending);',
      '}',
    ],
    python: [
      'def partition(arr, low, high, ascending=True):',
      '    pivot = arr[high]',
      '    i = low - 1',
      '    for j in range(low, high):',
      '        should_swap = False',
      '        if ascending:',
      '            if arr[j] <= pivot:',
      '                should_swap = True',
      '        else:  # descending',
      '            if arr[j] >= pivot:',
      '                should_swap = True',
      '        if should_swap:',
      '            i += 1',
      '            arr[i], arr[j] = arr[j], arr[i]',
      '    arr[i + 1], arr[high] = arr[high], arr[i + 1]',
      '    return i + 1',
      '',
      'def quick_sort_recursive(arr, low, high, ascending=True):',
      '    if low < high:',
      '        pi = partition(arr, low, high, ascending)',
      '        quick_sort_recursive(arr, low, pi - 1, ascending)',
      '        quick_sort_recursive(arr, pi + 1, high, ascending)',
      '',
      'def quick_sort(arr, ascending=True):',
      '    if len(arr) <= 1:',
      '        return arr',
      '    quick_sort_recursive(arr, 0, len(arr) - 1, ascending)',
      '    return arr # Or modify in-place and not return for consistency',
    ],
  },
  pseudoCodeMapping: {
    0: { c: [36], cpp: [32], python: [24] },
    1: { c: [38], cpp: [34], python: [27] },
    2: { c: [39], cpp: [35], python: [28] },
    3: { c: [27], cpp: [24], python: [18] },
    4: { c: [28], cpp: [25], python: [19] },
    5: { c: [29], cpp: [26], python: [20] },
    6: { c: [30], cpp: [27], python: [21] },
    7: { c: [31], cpp: [28], python: [22] },
    8: { c: [32], cpp: [29], python: [22] },
    9: { c: [33], cpp: [30], python: [22] },
    10: { c: [9], cpp: [5], python: [1] },
    11: { c: [10], cpp: [6], python: [2] },
    12: { c: [11], cpp: [7], python: [3] },
    13: { c: [12], cpp: [8], python: [4] },
    14: { c: [13, 14, 15, 16, 17], cpp: [9, 10, 11, 12, 13], python: [5, 6, 7, 8, 9, 10, 11] },
    15: { c: [19], cpp: [15], python: [13] },
    16: { c: [20], cpp: [16], python: [14] },
    17: { c: [21], cpp: [17], python: [11] },
    18: { c: [22], cpp: [18], python: [4] },
    19: { c: [23], cpp: [19], python: [15] },
    20: { c: [24], cpp: [20], python: [16] },
    21: { c: [25], cpp: [21], python: [16] },
  },
  performancePaths: {
    best: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21],
    worst: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21],
    average: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21],
  },
  hasAdvancedAuxiliaryVisuals: false,
}
