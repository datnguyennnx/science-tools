'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { quickSortGenerator } from '../algorithms'

export const quickSortData: SortAlgorithm = {
  id: 'quickSort',
  name: 'Quick Sort',
  description:
    'Developed by Tony Hoare in 1959 while working on machine translation, Quick Sort is a highly efficient, widely used sorting algorithm that also follows the divide-and-conquer paradigm. It selects a "pivot" element from the array and partitions the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then sorted recursively. Hoare famously conceived the algorithm during a lunch break, initially struggling with the details but recognizing its potential for speed.',
  generator: quickSortGenerator,
  complexity: {
    time: { best: 'O(n log n)', average: 'O(n log n)', worst: 'O(n^2)' },
    space: 'O(log n)',
  },
  origin: { name: 'Tony Hoare', year: 1959 },
  img: 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/2c/Sir_Tony_Hoare_IMG_5125.jpg/1200px-Sir_Tony_Hoare_IMG_5125.jpg',
  pseudoCodes: {
    plaintext: [
      'procedure quickSort(list, low, high, direction)',
      '  if low < high then',
      '    pivotIndex = partition(list, low, high, direction)',
      '    quickSort(list, low, pivotIndex - 1, direction)',
      '    quickSort(list, pivotIndex + 1, high, direction)',
      '  end if',
      'end procedure',
      '',
      'procedure partition(list, low, high, direction)',
      '  pivot = list[high]',
      '  i = low - 1',
      '  for j = low to high - 1',
      '    if (direction == ASC and list[j] <= pivot) or (direction == DESC and list[j] >= pivot) then',
      '      i = i + 1',
      '      swap(list[i], list[j])',
      '    end if',
      '  end for',
      '  swap(list[i + 1], list[high])',
      '  return i + 1',
      'end procedure',
    ],
    c: [
      '#include <stdbool.h>',
      '',
      'void swap(int* a, int* b) {',
      '  int t = *a;',
      '  *a = *b;',
      '  *b = t;',
      '}',
      '',
      'int partition(int arr[], int low, int high, bool ascending) {',
      '  int pivot = arr[high];',
      '  int i = (low - 1);',
      '  for (int j = low; j <= high - 1; j++) {',
      '    bool conditionMet;',
      '    if (ascending) {',
      '      conditionMet = (arr[j] <= pivot);',
      '    } else {',
      '      conditionMet = (arr[j] >= pivot);',
      '    }',
      '    if (conditionMet) {',
      '      i++;',
      '      swap(&arr[i], &arr[j]);',
      '    }',
      '  }',
      '  swap(&arr[i + 1], &arr[high]);',
      '  return (i + 1);',
      '}',
      '',
      'void quickSort(int arr[], int low, int high, bool ascending) {',
      '  if (low < high) {',
      '    int pi = partition(arr, low, high, ascending);',
      '    quickSort(arr, low, pi - 1, ascending);',
      '    quickSort(arr, pi + 1, high, ascending);',
      '  }',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <utility>',
      '#include <stdbool.h>',
      '',
      'template <typename T>',
      'int partition(T& arr, int low, int high, bool ascending) {',
      '  int pivot = arr[high]; ',
      '  int i = (low - 1);',
      '  for (int j = low; j <= high - 1; j++) {',
      '    bool conditionMet;',
      '    if (ascending) {',
      '      conditionMet = (arr[j] <= pivot);',
      '    } else {',
      '      conditionMet = (arr[j] >= pivot);',
      '    }',
      '    if (conditionMet) {',
      '      i++;',
      '      std::swap(arr[i], arr[j]);',
      '    }',
      '  }',
      '  std::swap(arr[i + 1], arr[high]);',
      '  return (i + 1);',
      '}',
      '',
      'void quickSort(int arr[], int low, int high, bool ascending) {',
      '  if (low < high) {',
      '    int pi = partition(arr, low, high, ascending);',
      '    quickSort(arr, low, pi - 1, ascending);',
      '    quickSort(arr, pi + 1, high, ascending);',
      '  }',
      '}',
      '',
      'void quickSort(std::vector<int>& arr, int low, int high, bool ascending) {',
      '  if (low < high) {',
      '    int pi = partition(arr, low, high, ascending);',
      '    quickSort(arr, low, pi - 1, ascending);',
      '    quickSort(arr, pi + 1, high, ascending);',
      '  }',
      '}',
    ],
    python: [
      'def partition(arr, low, high, ascending=True):',
      '  pivot = arr[high]',
      '  i = low - 1',
      '  for j in range(low, high):',
      '    condition_met = False',
      '    if ascending:',
      '      if arr[j] <= pivot:',
      '        condition_met = True',
      '    else:',
      '      if arr[j] >= pivot:',
      '        condition_met = True',
      '    ',
      '    if condition_met:',
      '      i += 1',
      '      arr[i], arr[j] = arr[j], arr[i]',
      '  arr[i + 1], arr[high] = arr[high], arr[i + 1]',
      '  return i + 1',
      '',
      'def quick_sort(arr, low, high, ascending=True):',
      '  if low < high:',
      '    pi = partition(arr, low, high, ascending)',
      '    quick_sort(arr, low, pi - 1, ascending)',
      '    quick_sort(arr, pi + 1, high, ascending)',
    ],
  },
  pseudoCodeMapping: {
    0: { c: [27], cpp: [24, 31], python: [18] },
    1: { c: [28], cpp: [25, 32], python: [19] },
    2: { c: [29], cpp: [26, 33], python: [20] },
    3: { c: [30], cpp: [27, 34], python: [21] },
    4: { c: [31], cpp: [28, 35], python: [22] },
    5: { c: [28], cpp: [25, 32], python: [19] },
    6: { c: [32], cpp: [29, 36], python: [18] },

    8: { c: [8], cpp: [5], python: [0] },
    9: { c: [9], cpp: [6], python: [1] },
    10: { c: [10], cpp: [7], python: [2] },
    11: { c: [11], cpp: [8], python: [3] },
    12: { c: [13, 16], cpp: [10, 13], python: [6, 9] },
    13: { c: [18], cpp: [15], python: [13] },
    14: { c: [19], cpp: [16], python: [14] },
    15: { c: [13, 16], cpp: [10, 13], python: [6, 9] },
    16: { c: [11], cpp: [8], python: [3] },
    17: { c: [22], cpp: [20], python: [15] },
    18: { c: [23], cpp: [21], python: [16] },
    19: { c: [24], cpp: [22], python: [16] },
  },
  hasAdvancedAuxiliaryVisuals: false,
}
