'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { gnomeSortGenerator } from '../algorithms'

export const gnomeSortData: SortAlgorithm = {
  id: 'gnomeSort',
  name: 'Gnome Sort',
  description:
    'Originally called "Stupid Sort," Gnome Sort is a simple sorting algorithm conceived by Hamid Sarbazi-Azad and later described and named "Gnome Sort" by Dick Grune. It is similar to Insertion Sort but instead of using nested loops to find the insertion position, it repeatedly compares adjacent elements and swaps them if they are in the wrong order, moving back only when a swap occurs. It\'s known for its simplicity and is often used as an educational example.',
  generator: gnomeSortGenerator,
  complexity: { time: { best: 'O(n)', average: 'O(n^2)', worst: 'O(n^2)' }, space: 'O(1)' },
  origin: { name: 'Hamid Sarbazi-Azad / Dick Grune', year: 2000 },
  img: 'https://sharif.edu/~azad/Works_files/image003.jpg',
  pseudoCodes: {
    plaintext: [
      'procedure gnomeSort(list, direction)',
      '  index = 0',
      '  n = length of list',
      '  while index < n',
      '    if index == 0 then',
      '      index = index + 1',
      '    else if (direction == ASC and list[index] >= list[index - 1]) or (direction == DESC and list[index] <= list[index - 1]) then',
      '      index = index + 1',
      '    else',
      '      swap(list[index], list[index - 1])',
      '      index = index - 1',
      '    end if',
      '  end while',
      'end procedure',
    ],
    c: [
      '#include <stdbool.h>',
      '',
      'typedef enum { ASC, DESC } SortDirection;',
      '',
      'void swap(int *a, int *b) {',
      '    int temp = *a;',
      '    *a = *b;',
      '    *b = temp;',
      '}',
      '',
      'void gnomeSort(int arr[], int n, SortDirection direction) {',
      '  if (n <= 1) return;',
      '  int index = 0;',
      '  while (index < n) {',
      '    if (index == 0) {',
      '      index++;',
      '    } else {',
      '      bool in_order = false;',
      '      if (direction == ASC) {',
      '        if (arr[index] >= arr[index - 1]) in_order = true;',
      '      } else {',
      '        if (arr[index] <= arr[index - 1]) in_order = true;',
      '      }',
      '      if (in_order) {',
      '        index++;',
      '      } else {',
      '        swap(&arr[index], &arr[index - 1]);',
      '        index--;',
      '      }',
      '    }',
      '  }',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <utility>',
      '',
      'enum class SortDirection { ASC, DESC };',
      '',
      'void gnomeSort(std::vector<int>& arr, SortDirection direction) {',
      '  int n = arr.size();',
      '  if (n <= 1) return;',
      '  int index = 0;',
      '  while (index < n) {',
      '    if (index == 0) {',
      '      index++;',
      '    } else {',
      '      bool in_order = false;',
      '      if (direction == SortDirection::ASC) {',
      '        if (arr[index] >= arr[index - 1]) in_order = true;',
      '      } else {',
      '        if (arr[index] <= arr[index - 1]) in_order = true;',
      '      }',
      '      if (in_order) {',
      '        index++;',
      '      } else {',
      '        std::swap(arr[index], arr[index - 1]);',
      '        index--;',
      '      }',
      '    }',
      '  }',
      '}',
    ],
    python: [
      'def gnome_sort(arr, direction="asc"):',
      '  n = len(arr)',
      '  if n <= 1:',
      '    return arr',
      '  index = 0',
      '  while index < n:',
      '    if index == 0:',
      '      index += 1',
      '    else:',
      '      in_order = False',
      '      if direction == "asc":',
      '        if arr[index] >= arr[index - 1]:',
      '          in_order = True',
      '      else:',
      '        if arr[index] <= arr[index - 1]:',
      '          in_order = True',
      '      ',
      '      if in_order:',
      '        index += 1',
      '      else:',
      '        arr[index], arr[index - 1] = arr[index - 1], arr[index]',
      '        index -= 1',
      '  return arr',
    ],
  },
  pseudoCodeMapping: {
    0: { c: [10], cpp: [5], python: [0] },
    1: { c: [12], cpp: [8], python: [4] },
    2: { c: [11], cpp: [6, 7], python: [1, 2, 3] },
    3: { c: [13], cpp: [9], python: [5] },
    4: { c: [14], cpp: [10], python: [6] },
    5: { c: [15], cpp: [11], python: [7] },
    6: {
      c: [17, 18, 19, 20, 21, 23],
      cpp: [13, 14, 15, 16, 17, 19],
      python: [9, 10, 11, 12, 13, 14, 15, 17],
    },
    7: { c: [24], cpp: [20], python: [18] },
    8: { c: [25], cpp: [21], python: [19] },
    9: { c: [26], cpp: [22], python: [20] },
    10: { c: [27], cpp: [23], python: [21] },
    11: { c: [28, 29], cpp: [24, 25], python: [] },
    12: { c: [30], cpp: [26], python: [] },
    13: { c: [31], cpp: [27], python: [22] },
  },
  hasAdvancedAuxiliaryVisuals: false,
}
