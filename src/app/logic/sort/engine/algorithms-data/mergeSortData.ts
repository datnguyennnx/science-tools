'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { mergeSortGenerator } from '../algorithms'

export const mergeSortData: SortAlgorithm = {
  id: 'mergeSort',
  name: 'Merge Sort',
  description:
    'Invented by John von Neumann in 1945, Merge Sort is a classic example of a divide-and-conquer algorithm. It works by recursively dividing the unsorted list into n sublists, each containing one element (a list of one element is considered sorted). Then, it repeatedly merges sublists to produce new sorted sublists until there is only one sublist remaining, which is the sorted list. Its guaranteed O(n log n) time complexity makes it a stable and efficient choice for sorting large datasets.',
  generator: mergeSortGenerator,
  complexity: {
    time: { best: 'O(n log n)', average: 'O(n log n)', worst: 'O(n log n)' },
    space: 'O(n)',
  },
  origin: { name: 'John von Neumann', year: 1945 },
  img: 'https://upload.wikimedia.org/wikipedia/commons/5/5e/JohnvonNeumann-LosAlamos.gif',
  pseudoCodes: {
    plaintext: [
      'procedure mergeSort(list, left, right)',
      '  if left < right then',
      '    middle = left + (right - left) / 2',
      '    mergeSort(list, left, middle)',
      '    mergeSort(list, middle + 1, right)',
      '    merge(list, left, middle, right)',
      '  end if',
      'end procedure',
      '',
      'procedure merge(list, left, middle, right)',
      '  n1 = middle - left + 1',
      '  n2 = right - middle',
      '  create array L of size n1',
      '  create array R of size n2',
      '  for i = 0 to n1 - 1',
      '    L[i] = list[left + i]',
      '  end for',
      '  for j = 0 to n2 - 1',
      '    R[j] = list[middle + 1 + j]',
      '  end for',
      '  i = 0',
      '  j = 0',
      '  k = left',
      '  while i < n1 and j < n2',
      '    // For ascending sort: L[i] <= R[j] (for stability)',
      '    // For descending sort: L[i] >= R[j] (for stability)',
      '    if L[i] <= R[j] then // Defaulting to ascending sort logic',
      '      list[k] = L[i]',
      '      i = i + 1',
      '    else',
      '      list[k] = R[j]',
      '      j = j + 1',
      '    end if',
      '    k = k + 1',
      '  end while',
      '  while i < n1',
      '    list[k] = L[i]',
      '    i = i + 1',
      '    k = k + 1',
      '  end while',
      '  while j < n2',
      '    list[k] = R[j]',
      '    j = j + 1',
      '    k = k + 1',
      '  end while',
      'end procedure',
    ],
    c: [
      '// Note: Uses Variable Length Arrays (VLAs) for L and R, a C99 feature.',
      '// For older C standards or C++, dynamic allocation (e.g., malloc/free or std::vector) would be used.',
      'void merge(int arr[], int l, int m, int r) {',
      '  int i, j, k;',
      '  int n1 = m - l + 1;',
      '  int n2 = r - m;',
      '  int L[n1], R[n2]; // VLA usage',
      '  for (i = 0; i < n1; i++)',
      '    L[i] = arr[l + i];',
      '  for (j = 0; j < n2; j++)',
      '    R[j] = arr[m + 1 + j];',
      '  i = 0;',
      '  j = 0;',
      '  k = l;',
      '  while (i < n1 && j < n2) {',
      '    // For ascending sort: L[i] <= R[j] (for stability)',
      '    // For descending sort: L[i] >= R[j] (for stability)',
      '    if (L[i] <= R[j]) { // Defaulting to ascending sort logic',
      '      arr[k] = L[i];',
      '      i++;',
      '    } else {',
      '      arr[k] = R[j];',
      '      j++;',
      '    }',
      '    k++;',
      '  }',
      '  while (i < n1) {',
      '    arr[k] = L[i];',
      '    i++;',
      '    k++;',
      '  }',
      '  while (j < n2) {',
      '    arr[k] = R[j];',
      '    j++;',
      '    k++;',
      '  }',
      '}',
      '',
      'void mergeSort(int arr[], int l, int r) {',
      '  if (l < r) {',
      '    int m = l + (r - l) / 2;',
      '    mergeSort(arr, l, m);',
      '    mergeSort(arr, m + 1, r);',
      '    merge(arr, l, m, r);',
      '  }',
      '}',
    ],
    cpp: [
      '#include <vector> // Required for std::vector',
      '',
      'void merge(int arr[], int l, int m, int r) {',
      '  int n1 = m - l + 1;',
      '  int n2 = r - m;',
      '  std::vector<int> L(n1), R(n2);',
      '  for (int i = 0; i < n1; i++)',
      '    L[i] = arr[l + i];',
      '  for (int j = 0; j < n2; j++)',
      '    R[j] = arr[m + 1 + j];',
      '  int i = 0, j = 0, k = l;',
      '  while (i < n1 && j < n2) {',
      '    // For ascending sort: L[i] <= R[j] (for stability)',
      '    // For descending sort: L[i] >= R[j] (for stability)',
      '    if (L[i] <= R[j]) { // Defaulting to ascending sort logic',
      '      arr[k] = L[i];',
      '      i++;',
      '    } else {',
      '      arr[k] = R[j];',
      '      j++;',
      '    }',
      '    k++;',
      '  }',
      '  while (i < n1) {',
      '    arr[k] = L[i];',
      '    i++;',
      '    k++;',
      '  }',
      '  while (j < n2) {',
      '    arr[k] = R[j];',
      '    j++;',
      '    k++;',
      '  }',
      '}',
      '',
      'void mergeSort(int arr[], int l, int r) {',
      '  if (l < r) {',
      '    int m = l + (r - l) / 2;',
      '    mergeSort(arr, l, m);',
      '    mergeSort(arr, m + 1, r);',
      '    merge(arr, l, m, r);',
      '  }',
      '}',
    ],
    python: [
      '# Merge Sort in Python. This implementation modifies the array in-place,',
      '# but the merge step uses O(n) auxiliary space for temporary L and R arrays.',
      'def merge(arr, l, m, r):',
      '  n1 = m - l + 1',
      '  n2 = r - m',
      '  L = [0] * n1',
      '  R = [0] * n2',
      '  for i in range(n1):',
      '    L[i] = arr[l + i]',
      '  for j in range(n2):',
      '    R[j] = arr[m + 1 + j]',
      '  i = 0',
      '  j = 0',
      '  k = l',
      '  while i < n1 and j < n2:',
      '    if L[i] <= R[j]: # For descending, use L[i] >= R[j]',
      '      arr[k] = L[i]',
      '      i += 1',
      '    else:',
      '      arr[k] = R[j]',
      '      j += 1',
      '    k += 1',
      '  while i < n1:',
      '    arr[k] = L[i]',
      '    i += 1',
      '    k += 1',
      '  while j < n2:',
      '    arr[k] = R[j]',
      '    j += 1',
      '    k += 1',
      '',
      'def merge_sort(arr, l, r):',
      '  if l < r:',
      '    m = l + (r - l) // 2',
      '    merge_sort(arr, l, m)',
      '    merge_sort(arr, m + 1, r)',
      '    merge(arr, l, m, r)',
    ],
  },
}
