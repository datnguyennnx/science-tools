'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { mergeSortGenerator } from '../algorithms'

export const mergeSortData: SortAlgorithm = {
  id: 'mergeSort',
  name: 'Merge Sort',
  description:
    'Invented by John von Neumann in 1945, Merge Sort is a classic example of a divide-and-conquer algorithm. It works by recursively dividing the unsorted list into n sublists, each containing one element (a list of one element is considered sorted). Then, it repeatedly merges sublists to produce new sorted sublists until there is only one sublist remaining, which is the sorted list. Its guaranteed O(n log n) time complexity makes it a stable and efficient choice for sorting large datasets.',
  generator: mergeSortGenerator,
  complexity: {
    time: { best: 'O(n log n)', average: 'O(n log n)', worst: 'O(n log n)' },
    space: 'O(n)',
  },
  origin: { name: 'John von Neumann', year: 1945 },
  img: 'https://upload.wikimedia.org/wikipedia/commons/5/5e/JohnvonNeumann-LosAlamos.gif',
  pseudoCodes: {
    plaintext: [
      'procedure mergeSort(list, direction)',
      '  n = length of list',
      '  if n <= 1 then return list',
      '  _mergeSortRecursive(list, 0, n - 1, direction)',
      '  return list',
      'end procedure',
      '',
      'procedure _mergeSortRecursive(list, left, right, direction)',
      '  if left < right then',
      '    middle = left + floor((right - left) / 2)',
      '    _mergeSortRecursive(list, left, middle, direction)',
      '    _mergeSortRecursive(list, middle + 1, right, direction)',
      '    _merge(list, left, middle, right, direction)',
      '  end if',
      'end procedure',
      '',
      'procedure _merge(list, left, middle, right, direction)',
      '  n1 = middle - left + 1',
      '  n2 = right - middle',
      '  create array L of size n1',
      '  create array R of size n2',
      '  for i = 0 to n1 - 1',
      '    L[i] = list[left + i]',
      '  end for',
      '  for j = 0 to n2 - 1',
      '    R[j] = list[middle + 1 + j]',
      '  end for',
      '  i = 0',
      '  j = 0',
      '  k = left',
      '  while i < n1 and j < n2',
      '    if (direction == ASC and L[i] <= R[j]) or (direction == DESC and L[i] >= R[j]) then',
      '      list[k] = L[i]',
      '      i = i + 1',
      '    else',
      '      list[k] = R[j]',
      '      j = j + 1',
      '    end if',
      '    k = k + 1',
      '  end while',
      '  while i < n1',
      '    list[k] = L[i]',
      '    i = i + 1',
      '    k = k + 1',
      '  end while',
      '  while j < n2',
      '    list[k] = R[j]',
      '    j = j + 1',
      '    k = k + 1',
      '  end while',
      'end procedure',
    ],
    c: [
      '#include <stdlib.h>',
      '#include <stdbool.h>',
      '',
      'typedef enum { ASC, DESC } SortDirection;',
      '',
      'void _merge(int arr[], int l, int m, int r, SortDirection direction) {',
      '  int i, j, k;',
      '  int n1 = m - l + 1;',
      '  int n2 = r - m;',
      '  int *L = (int*)malloc(n1 * sizeof(int));',
      '  int *R = (int*)malloc(n2 * sizeof(int));',
      '  if (L == NULL || R == NULL) { if(L) free(L); if(R) free(R); return; }',
      '',
      '  for (i = 0; i < n1; i++)',
      '    L[i] = arr[l + i];',
      '  for (j = 0; j < n2; j++)',
      '    R[j] = arr[m + 1 + j];',
      '',
      '  i = 0;',
      '  j = 0;',
      '  k = l;',
      '  while (i < n1 && j < n2) {',
      '    bool conditionMet;',
      '    if (direction == ASC) conditionMet = (L[i] <= R[j]);',
      '    else conditionMet = (L[i] >= R[j]);',
      '    if (conditionMet) {',
      '      arr[k] = L[i];',
      '      i++;',
      '    } else {',
      '      arr[k] = R[j];',
      '      j++;',
      '    }',
      '    k++;',
      '  }',
      '  while (i < n1) {',
      '    arr[k] = L[i];',
      '    i++;',
      '    k++;',
      '  }',
      '  while (j < n2) {',
      '    arr[k] = R[j];',
      '    j++;',
      '    k++;',
      '  }',
      '  free(L);',
      '  free(R);',
      '}',
      '',
      'void _mergeSortRecursive(int arr[], int l, int r, SortDirection direction) {',
      '  if (l < r) {',
      '    int m = l + (r - l) / 2;',
      '    _mergeSortRecursive(arr, l, m, direction);',
      '    _mergeSortRecursive(arr, m + 1, r, direction);',
      '    _merge(arr, l, m, r, direction);',
      '  }',
      '}',
      '',
      'void mergeSort(int arr[], int n, SortDirection direction) {',
      '  if (n <= 1) return;',
      ' _mergeSortRecursive(arr, 0, n - 1, direction);',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <algorithm>',
      '',
      'enum class SortDirection { ASC, DESC };',
      '',
      'void _merge(std::vector<int>& arr, int l, int m, int r, SortDirection direction) {',
      '  int n1 = m - l + 1;',
      '  int n2 = r - m;',
      '  std::vector<int> L(n1);',
      '  std::vector<int> R(n2);',
      '  for (int i = 0; i < n1; i++)',
      '    L[i] = arr[l + i];',
      '  for (int j = 0; j < n2; j++)',
      '    R[j] = arr[m + 1 + j];',
      '',
      '  int i = 0, j = 0, k = l;',
      '  while (i < n1 && j < n2) {',
      '    bool conditionMet;',
      '    if (direction == SortDirection::ASC) conditionMet = (L[i] <= R[j]);',
      '    else conditionMet = (L[i] >= R[j]);',
      '    if (conditionMet) {',
      '      arr[k] = L[i];',
      '      i++;',
      '    } else {',
      '      arr[k] = R[j];',
      '      j++;',
      '    }',
      '    k++;',
      '  }',
      '  while (i < n1) {',
      '    arr[k] = L[i];',
      '    i++;',
      '    k++;',
      '  }',
      '  while (j < n2) {',
      '    arr[k] = R[j];',
      '    j++;',
      '    k++;',
      '  }',
      '}',
      '',
      'void _mergeSortRecursive(std::vector<int>& arr, int l, int r, SortDirection direction) {',
      '  if (l < r) {',
      '    int m = l + (r - l) / 2;',
      '    _mergeSortRecursive(arr, l, m, direction);',
      '    _mergeSortRecursive(arr, m + 1, r, direction);',
      '    _merge(arr, l, m, r, direction);',
      '  }',
      '}',
      '',
      'void mergeSort(std::vector<int>& arr, SortDirection direction) {',
      '  int n = arr.size();',
      '  if (n <= 1) return;',
      '  _mergeSortRecursive(arr, 0, n - 1, direction);',
      '}',
    ],
    python: [
      'def _merge(arr, l, m, r, direction="asc"):',
      '  n1 = m - l + 1',
      '  n2 = r - m',
      '  L = [0] * n1',
      '  R = [0] * n2',
      '  for i in range(n1):',
      '    L[i] = arr[l + i]',
      '  for j in range(n2):',
      '    R[j] = arr[m + 1 + j]',
      '  i = 0',
      '  j = 0',
      '  k = l',
      '  while i < n1 and j < n2:',
      '    condition_met = False',
      '    if direction == "asc":',
      '      condition_met = L[i] <= R[j]',
      '    else:',
      '      condition_met = L[i] >= R[j]',
      '    if condition_met:',
      '      arr[k] = L[i]',
      '      i += 1',
      '    else:',
      '      arr[k] = R[j]',
      '      j += 1',
      '    k += 1',
      '  while i < n1:',
      '    arr[k] = L[i]',
      '    i += 1',
      '    k += 1',
      '  while j < n2:',
      '    arr[k] = R[j]',
      '    j += 1',
      '    k += 1',
      '',
      'def _merge_sort_recursive(arr, l, r, direction="asc"):',
      '  if l < r:',
      '    m = l + (r - l) // 2',
      '    _merge_sort_recursive(arr, l, m, direction)',
      '    _merge_sort_recursive(arr, m + 1, r, direction)',
      '    _merge(arr, l, m, r, direction)',
      '',
      'def merge_sort(arr, direction="asc"):',
      '  n = len(arr)',
      '  if n <= 1:',
      '    return arr',
      '  _merge_sort_recursive(arr, 0, n - 1, direction)',
      '  return arr',
    ],
  },
  pseudoCodeMapping: {
    0: { c: [50], cpp: [45], python: [40] },
    1: { c: [51], cpp: [46], python: [41] },
    2: { c: [51], cpp: [46], python: [42] },
    3: { c: [52], cpp: [47], python: [44] },
    4: { python: [45] },
    5: { c: [53], cpp: [48], python: [45] },

    7: { c: [42], cpp: [37], python: [34] },
    8: { c: [43], cpp: [38], python: [35] },
    9: { c: [44], cpp: [39], python: [36] },
    10: { c: [45], cpp: [40], python: [37] },
    11: { c: [46], cpp: [41], python: [38] },
    12: { c: [47], cpp: [42], python: [39] },
    13: { c: [48], cpp: [43], python: [35] },
    14: { c: [49], cpp: [44], python: [39] },

    16: { c: [5], cpp: [5], python: [0] },
    17: { c: [7], cpp: [6], python: [1] },
    18: { c: [8], cpp: [7], python: [2] },
    19: { c: [9], cpp: [8], python: [3] },
    20: { c: [10], cpp: [9], python: [4] },
    21: { c: [13], cpp: [10], python: [5] },
    22: { c: [14], cpp: [11], python: [6] },
    23: { c: [13], cpp: [10], python: [5] },
    24: { c: [15], cpp: [12], python: [7] },
    25: { c: [16], cpp: [13], python: [8] },
    26: { c: [15], cpp: [12], python: [7] },
    27: { c: [18], cpp: [15], python: [9] },
    28: { c: [19], cpp: [15], python: [10] },
    29: { c: [20], cpp: [15], python: [11] },
    30: { c: [21], cpp: [16], python: [12] },
    31: { c: [22, 23, 24], cpp: [17, 18, 19], python: [14, 15, 16, 17] },
    32: { c: [25], cpp: [20], python: [20] },
    33: { c: [26], cpp: [21], python: [21] },
    34: { c: [27], cpp: [22], python: [22] },
    35: { c: [28], cpp: [23], python: [23] },
    36: { c: [29], cpp: [24], python: [24] },
    37: { c: [30], cpp: [25], python: [19] },
    38: { c: [31], cpp: [26], python: [25] },
    39: { c: [21], cpp: [16], python: [12] },
    40: { c: [33], cpp: [28], python: [26] },
    41: { c: [34], cpp: [29], python: [27] },
    42: { c: [35], cpp: [30], python: [28] },
    43: { c: [36], cpp: [31], python: [29] },
    44: { c: [33], cpp: [28], python: [26] },
    45: { c: [38], cpp: [33], python: [30] },
    46: { c: [39], cpp: [34], python: [31] },
    47: { c: [40], cpp: [35], python: [32] },
    48: { c: [41], cpp: [36], python: [33] },
    49: { c: [38], cpp: [33], python: [30] },
    50: { c: [40], cpp: [37], python: [33] },
  },
  hasAdvancedAuxiliaryVisuals: false,
}
