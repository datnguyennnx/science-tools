'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { treeSortGenerator } from '../algorithms'

export const treeSortData: SortAlgorithm = {
  id: 'treeSort',
  name: 'Tree Sort',
  description:
    'Tree Sort utilizes a Binary Search Tree (BST) to sort elements. It works by inserting all elements from the input array into a BST. Due to the properties of a BST, an in-order traversal of the tree will visit the elements in sorted order. The motivation is to leverage the efficient insertion and ordering properties of a BST to achieve sorting. While the average time complexity is O(n log n), the worst-case can degrade to O(n^2) if the input data is already sorted or reverse-sorted, leading to a skewed tree.',
  generator: treeSortGenerator,
  complexity: {
    time: { best: 'O(n log n)', average: 'O(n log n)', worst: 'O(n^2)' },
    space: 'O(n)',
  },
  origin: { name: 'Fundamental (Using BST)' },
  img: '',
  pseudoCodes: {
    plaintext: [
      'procedure treeSort(list)',
      '  root = null',
      '  for each element in list',
      '    root = insert(root, element)',
      '  end for',
      '  sortedList = []',
      '  inOrderTraversal(root, sortedList)',
      '  return sortedList',
      'end procedure',
      '',
      'function insert(node, value)',
      '  if node is null then',
      '    return createNode(value)',
      '  end if',
      '  if value < node.data then',
      '    node.left = insert(node.left, value)',
      '  else // value >= node.data (handles duplicates by placing them in the right subtree)',
      '    node.right = insert(node.right, value)',
      '  end if',
      '  return node',
      'end function',
      '',
      'procedure inOrderTraversal(node, resultList)',
      '  // Standard in-order traversal (Left-Node-Right) yields ascending order from this BST structure.',
      '  // For descending order, use a reverse in-order traversal (Right-Node-Left).',
      '  if node is not null then',
      '    inOrderTraversal(node.left, resultList)',
      '    add node.data to resultList',
      '    inOrderTraversal(node.right, resultList)',
      '  end if',
      'end procedure',
    ],
    c: [
      '// Requires struct for TreeNode and functions for createNode, insert, inOrder.',
      'typedef struct TreeNode {',
      '  int data;',
      '  struct TreeNode *left;',
      '  struct TreeNode *right;',
      '} TreeNode;',
      '',
      'TreeNode* createNode(int data) { /* ... */ }',
      'TreeNode* insertNode(TreeNode* node, int data) { /* ... */ }',
      'void inOrder(TreeNode* root, int arr[], int* index_ptr) { /* ... */ }',
      '',
      'void treeSort(int arr[], int n) {',
      '  if (n == 0) return;',
      '  TreeNode* root = NULL;',
      '  for (int i = 0; i < n; i++) {',
      '    root = insertNode(root, arr[i]);',
      '  }',
      '  int index = 0;',
      '  inOrder(root, arr, &index);',
      '  // Free tree memory if dynamically allocated',
      '}',
      '',
      '// Implementation for insertNode (example):',
      '// TreeNode* insertNode(TreeNode* node, int data) {',
      '//   if (node == NULL) return createNode(data); ',
      '//   if (data < node->data) node->left = insertNode(node->left, data);',
      '//   else node->right = insertNode(node->right, data); // data >= node->data goes right',
      '//   return node;',
      '',
      '// Implementation for inOrder (example):',
      '// void inOrder(TreeNode* root, int arr[], int* index_ptr) {',
      '//   // Standard in-order (Left-Node-Right) for ascending.',
      '//   // For descending, traverse: root->right, then root, then root->left.',
      '//   if (root != NULL) {',
      '//     inOrder(root->left, arr, index_ptr);',
      '//     arr[(*index_ptr)++] = root->data;',
      '//     inOrder(root->right, arr, index_ptr);',
      '//   }',
      '// }',
    ],
    cpp: [
      '#include <vector>',
      '#include <functional> // For std::function if used for traversal',
      '',
      'struct TreeNode {',
      '  int data;',
      '  TreeNode *left;',
      '  TreeNode *right;',
      '  TreeNode(int val) : data(val), left(nullptr), right(nullptr) {}',
      '};',
      '',
      'TreeNode* insert(TreeNode* node, int data) {',
      '  if (!node) return new TreeNode(data);',
      '  if (data < node->data) {',
      '    node->left = insert(node->left, data);',
      '  } else { // data >= node->data goes right',
      '    node->right = insert(node->right, data);',
      '  }',
      '  return node;',
      '}',
      '',
      'void inOrderTraversal(TreeNode* node, std::vector<int>& result) {',
      '  // Standard in-order (Left-Node-Right) for ascending.',
      '  // For descending, traverse: node->right, then node, then node->left.',
      '  if (!node) return;',
      '  inOrderTraversal(node->left, result);',
      '  result.push_back(node->data);',
      '  inOrderTraversal(node->right, result);',
      '}',
      '',
      'void treeSort(std::vector<int>& arr) {',
      '  if (arr.empty()) return;',
      '  TreeNode* root = nullptr;',
      '  for (int x : arr) {',
      '    root = insert(root, x);',
      '  }',
      '  arr.clear();',
      '  inOrderTraversal(root, arr);',
      '  // Proper memory deallocation for TreeNode objects would be needed here.',
      '}',
    ],
    python: [
      'class TreeNode:',
      '    def __init__(self, key):',
      '        self.left = None',
      '        self.right = None',
      '        self.val = key',
      '',
      'def insert_node(node, key):',
      '    if node is None:',
      '        return TreeNode(key)',
      '    if key < node.val:',
      '        node.left = insert_node(node.left, key)',
      '    else: # key >= node.val goes right',
      '        node.right = insert_node(node.right, key)',
      '    return node',
      '',
      'def inorder_traversal_to_list(node, result_list):',
      '    # Standard in-order (Left-Node-Right) for ascending.',
      '    # For descending, traverse: node.right, then node, then node.left.',
      '    if node:',
      '        inorder_traversal_to_list(node.left, result_list)',
      '        result_list.append(node.val)',
      '        inorder_traversal_to_list(node.right, result_list)',
      '',
      'def tree_sort(arr):',
      '    if not arr:',
      '        return []',
      '    root = None',
      '    for x in arr:',
      '        root = insert_node(root, x)',
      '    ',
      '    sorted_list = []',
      '    inorder_traversal_to_list(root, sorted_list)',
      '    # To modify original array:',
      '    # for i in range(len(arr)):',
      '    #     arr[i] = sorted_list[i]',
      '    # return arr',
      '    return sorted_list',
    ],
  },
  hasAdvancedAuxiliaryVisuals: true,
}
