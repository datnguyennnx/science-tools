'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { treeSortGenerator } from '../algorithms'

export const treeSortData: SortAlgorithm = {
  id: 'treeSort',
  name: 'Tree Sort',
  description:
    'Tree Sort utilizes a Binary Search Tree (BST) to sort elements. It works by inserting all elements from the input array into a BST. Due to the properties of a BST, an in-order traversal of the tree will visit the elements in sorted order. The motivation is to leverage the efficient insertion and ordering properties of a BST to achieve sorting. While the average time complexity is O(n log n), the worst-case can degrade to O(n^2) if the input data is already sorted or reverse-sorted, leading to a skewed tree.',
  generator: treeSortGenerator,
  complexity: {
    time: { best: 'O(n log n)', average: 'O(n log n)', worst: 'O(n^2)' },
    space: 'O(n)',
  },
  origin: { name: 'Fundamental (Using BST)' },
  img: '',
  pseudoCodes: {
    plaintext: [
      'procedure treeSort(list, direction)',
      '  root = null',
      '  for each element in list',
      '    root = insert(root, element)',
      '  end for',
      '  sortedList = []',
      '  inOrderTraversal(root, sortedList, direction)',
      '  return sortedList',
      'end procedure',
      '',
      'function insert(node, value)',
      '  if node is null then',
      '    return createNode(value)',
      '  end if',
      '  if value < node.data then',
      '    node.left = insert(node.left, value)',
      '  else',
      '    node.right = insert(node.right, value)',
      '  end if',
      '  return node',
      'end function',
      '',
      'procedure inOrderTraversal(node, resultList, direction)',
      '  if node is not null then',
      '    if direction == ASC then',
      '      inOrderTraversal(node.left, resultList, direction)',
      '      add node.data to resultList',
      '      inOrderTraversal(node.right, resultList, direction)',
      '    else // direction == DESC',
      '      inOrderTraversal(node.right, resultList, direction)',
      '      add node.data to resultList',
      '      inOrderTraversal(node.left, resultList, direction)',
      '    end if',
      '  end if',
      'end procedure',
    ],
    c: [
      '#include <stdbool.h>',
      '#include <stdlib.h> // For NULL, malloc, free (if implementing createNode & free tree)',
      '',
      'typedef struct TreeNode {',
      '  int data;',
      '  struct TreeNode *left;',
      '  struct TreeNode *right;',
      '} TreeNode;',
      '',
      '// Caller is responsible for implementing these helper functions and memory management.',
      'TreeNode* createNode(int data);',
      'TreeNode* insertNode(TreeNode* node, int data);',
      'void inOrder(TreeNode* root, int arr[], int* index_ptr, bool ascending);',
      'void freeTree(TreeNode* root); // Important for memory management',
      '',
      'void treeSort(int arr[], int n, bool ascending) {',
      '  if (n == 0) return;',
      '  TreeNode* root = NULL;',
      '  for (int i = 0; i < n; i++) {',
      '    root = insertNode(root, arr[i]);',
      '  }',
      '  int index = 0;',
      '  inOrder(root, arr, &index, ascending);',
      '  freeTree(root); // Example of freeing memory',
      '}',
      '',
      '/* Example stubs for helpers:',
      'TreeNode* createNode(int data) {',
      '  TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));',
      '  if (!newNode) return NULL; // Handle allocation failure',
      '  newNode->data = data;',
      '  newNode->left = NULL;',
      '  newNode->right = NULL;',
      '  return newNode;',
      '}',
      '',
      'TreeNode* insertNode(TreeNode* node, int data) {',
      '  if (node == NULL) return createNode(data);',
      '  if (data < node->data) {',
      '    node->left = insertNode(node->left, data);',
      '  } else { // data >= node->data (duplicates to the right)',
      '    node->right = insertNode(node->right, data);',
      '  }',
      '  return node;',
      '}',
      '',
      'void inOrder(TreeNode* root, int arr[], int* index_ptr, bool ascending) {',
      '  if (root != NULL) {',
      '    if (ascending) {',
      '      inOrder(root->left, arr, index_ptr, ascending);',
      '      arr[(*index_ptr)++] = root->data;',
      '      inOrder(root->right, arr, index_ptr, ascending);',
      '    } else { // Descending',
      '      inOrder(root->right, arr, index_ptr, ascending);',
      '      arr[(*index_ptr)++] = root->data;',
      '      inOrder(root->left, arr, index_ptr, ascending);',
      '    }',
      '  }',
      '}',
      '',
      'void freeTree(TreeNode* root) {',
      '  if (root == NULL) return;',
      '  freeTree(root->left);',
      '  freeTree(root->right);',
      '  free(root);',
      '}',
      '*/',
    ],
    cpp: [
      '#include <vector>',
      '#include <functional>',
      '#include <stdbool.h>',
      '',
      'struct TreeNode {',
      '  int data;',
      '  TreeNode *left;',
      '  TreeNode *right;',
      '  TreeNode(int val) : data(val), left(nullptr), right(nullptr) {}',
      '};',
      '',
      'TreeNode* insert(TreeNode* node, int data) {',
      '  if (!node) return new TreeNode(data);',
      '  if (data < node->data) {',
      '    node->left = insert(node->left, data);',
      '  } else {',
      '    node->right = insert(node->right, data);',
      '  }',
      '  return node;',
      '}',
      '',
      'void inOrderTraversal(TreeNode* node, std::vector<int>& result, bool ascending) {',
      '  if (!node) return;',
      '  if (ascending) {',
      '    inOrderTraversal(node->left, result, ascending);',
      '    result.push_back(node->data);',
      '    inOrderTraversal(node->right, result, ascending);',
      '  } else {',
      '    inOrderTraversal(node->right, result, ascending);',
      '    result.push_back(node->data);',
      '    inOrderTraversal(node->left, result, ascending);',
      '  }',
      '}',
      '',
      'void deleteTree(TreeNode* node) {',
      '  if (node == nullptr) return;',
      '  deleteTree(node->left);',
      '  deleteTree(node->right);',
      '  delete node;',
      '}',
      '',
      'void treeSort(std::vector<int>& arr, bool ascending) {',
      '  if (arr.empty()) return;',
      '  TreeNode* root = nullptr;',
      '  for (int x : arr) {',
      '    root = insert(root, x);',
      '  }',
      '  arr.clear();',
      '  inOrderTraversal(root, arr, ascending);',
      '  deleteTree(root);',
      '}',
    ],
    python: [
      'class TreeNode:',
      '    def __init__(self, key):',
      '        self.left = None',
      '        self.right = None',
      '        self.val = key',
      '',
      'def insert_node(node, key):',
      '    if node is None:',
      '        return TreeNode(key)',
      '    if key < node.val:',
      '        node.left = insert_node(node.left, key)',
      '    else:',
      '        node.right = insert_node(node.right, key)',
      '    return node',
      '',
      'def inorder_traversal_to_list(node, result_list, ascending=True):',
      '    if node:',
      '        if ascending:',
      '            inorder_traversal_to_list(node.left, result_list, ascending)',
      '            result_list.append(node.val)',
      '            inorder_traversal_to_list(node.right, result_list, ascending)',
      '        else: # Descending',
      '            inorder_traversal_to_list(node.right, result_list, ascending)',
      '            result_list.append(node.val)',
      '            inorder_traversal_to_list(node.left, result_list, ascending)',
      '',
      'def tree_sort(arr, ascending=True):',
      '    if not arr:',
      '        return []',
      '    root = None',
      '    for x in arr:',
      '        root = insert_node(root, x)',
      '    ',
      '    sorted_list = []',
      '    inorder_traversal_to_list(root, sorted_list, ascending)',
      '    return sorted_list',
    ],
  },
  pseudoCodeMapping: {
    0: { c: [15], cpp: [36], python: [25] }, // procedure treeSort(list, direction)
    1: { c: [17], cpp: [38], python: [28] }, // root = null
    2: { c: [18], cpp: [39], python: [29] }, // for each element in list
    3: { c: [19], cpp: [40], python: [30] }, // root = insert(root, element)
    4: { c: [18], cpp: [39], python: [29] }, // end for (maps to for loop)
    5: { c: [21], cpp: [42], python: [32] }, // sortedList = []
    6: { c: [22], cpp: [43], python: [33] }, // inOrderTraversal(root, sortedList, direction)
    7: { python: [34] }, // return sortedList (Python specific)
    8: { c: [24], cpp: [45], python: [25] }, // end procedure (maps to main function body or end)

    10: { c: [35], cpp: [11], python: [6] }, // function insert(node, value)
    11: { c: [36], cpp: [12], python: [7] }, // if node is null then
    12: { c: [36], cpp: [12], python: [8] }, // return createNode(value)
    13: { c: [36], cpp: [12], python: [7] }, // end if (maps to if node is null)
    14: { c: [37], cpp: [13], python: [9] }, // if value < node.data then
    15: { c: [38], cpp: [14], python: [10] }, // node.left = insert(node.left, value)
    16: { c: [40], cpp: [16], python: [12] }, // else
    17: { c: [41], cpp: [17], python: [13] }, // node.right = insert(node.right, value)
    18: { cpp: [13, 16], python: [9, 12] }, // end if (maps to outer if/else for insert branch)
    19: { c: [43], cpp: [19], python: [14] }, // return node
    20: { c: [35], cpp: [11], python: [6] }, // end function (maps to function body)

    22: { c: [45], cpp: [21], python: [15] }, // procedure inOrderTraversal(node, resultList, direction)
    23: { c: [46], cpp: [22], python: [16] }, // if node is not null then
    24: { c: [47], cpp: [23], python: [17] }, // if direction == ASC then
    25: { c: [48], cpp: [24], python: [18] }, // inOrderTraversal(node.left, resultList, direction)
    26: { c: [49], cpp: [25], python: [19] }, // add node.data to resultList
    27: { c: [50], cpp: [26], python: [20] }, // inOrderTraversal(node.right, resultList, direction)
    28: { c: [51], cpp: [27], python: [21] }, // else // direction == DESC
    29: { c: [52], cpp: [28], python: [22] }, // inOrderTraversal(node.right, resultList, direction)
    30: { c: [53], cpp: [29], python: [23] }, // add node.data to resultList
    31: { c: [54], cpp: [30], python: [24] }, // inOrderTraversal(node.left, resultList, direction)
    32: { cpp: [23, 27], python: [17, 21] }, // end if (for asc/desc)
    33: { c: [46], cpp: [22], python: [16] }, // end if (for node is not null)
    34: { c: [45], cpp: [21], python: [15] }, // end procedure (maps to function body)
  },
  hasAdvancedAuxiliaryVisuals: true,
}
