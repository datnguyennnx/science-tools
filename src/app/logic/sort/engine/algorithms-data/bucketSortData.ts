'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { bucketSortGenerator } from '../algorithms'

export const bucketSortData: SortAlgorithm = {
  id: 'bucketSort',
  name: 'Bucket Sort',
  description:
    'Bucket Sort is a distribution sort algorithm that works by distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm, or by recursively applying the bucket sort algorithm. It is most effective when the input data is uniformly distributed over a range. The efficiency of Bucket Sort depends on the number of buckets and the algorithm used to sort the buckets.',
  generator: bucketSortGenerator,
  complexity: {
    time: { best: 'O(n+k)', average: 'O(n+k)', worst: 'O(n^2)' },
    space: 'O(n+k)',
  },
  origin: { name: 'Historical concept, refined over time', year: 'Known since 1940s/50s' },
  img: '',
  pseudoCodes: {
    plaintext: [
      'procedure bucketSort(list, direction, numBuckets)',
      '  if length of list <= 1 then return list',
      '  minVal = findMinValue(list)',
      '  maxVal = findMaxValue(list)',
      '  if minVal == maxVal then return list',
      '',
      '  if numBuckets is not specified then numBuckets = length of list',
      '  if numBuckets <= 0 then numBuckets = 1',
      '',
      '  create numBuckets empty buckets',
      '  rangePerBucket = (maxVal - minVal + 1.0) / numBuckets',
      '',
      '  for each element in list',
      '    bucketIndex = floor((element - minVal) / rangePerBucket)',
      '    if element == maxVal then bucketIndex = numBuckets - 1',
      '    bucketIndex = max(0, min(bucketIndex, numBuckets - 1))',
      '    add element to buckets[bucketIndex]',
      '  end for',
      '',
      '  for each bucket in buckets',
      '    insertionSort(bucket, direction)',
      '  end for',
      '',
      '  index = 0',
      '  for each bucket in buckets',
      '    for each element in bucket',
      '      list[index] = element',
      '      index = index + 1',
      '    end for',
      '  end for',
      '',
      '  return list',
      'end procedure',
      '',
      'procedure insertionSort(bucket, direction)',
      '  for i = 1 to length of bucket - 1',
      '    key = bucket[i]',
      '    j = i - 1',
      '    while j >= 0 and ((direction == ASC and bucket[j] > key) or (direction == DESC and bucket[j] < key))',
      '      bucket[j + 1] = bucket[j]',
      '      j = j - 1',
      '    end while',
      '    bucket[j + 1] = key',
      '  end for',
      'end procedure',
    ],
    c: [
      '#include <stdio.h>',
      '#include <stdlib.h>',
      '#include <stdbool.h>',
      '#include <math.h>',
      '#include <float.h>',
      '',
      'typedef enum { ASC, DESC } SortDirection;',
      '',
      'void insertionSortForBucket(int bucket[], int bucket_size, SortDirection direction) {',
      '    for (int i = 1; i < bucket_size; i++) {',
      '        int key = bucket[i];',
      '        int j = i - 1;',
      '        bool conditionMet;',
      '        if (direction == ASC) {',
      '            conditionMet = (j >= 0 && bucket[j] > key);',
      '        } else {',
      '            conditionMet = (j >= 0 && bucket[j] < key);',
      '        }',
      '        while (conditionMet) {',
      '            bucket[j + 1] = bucket[j];',
      '            j = j - 1;',
      '            if (j >= 0) {',
      '                if (direction == ASC) conditionMet = (bucket[j] > key);',
      '                else conditionMet = (bucket[j] < key);',
      '            } else {',
      '                conditionMet = false;',
      '            }',
      '        }',
      '        bucket[j + 1] = key;',
      '    }',
      '}',
      '',
      'typedef struct {',
      '    int* elements;',
      '    int count;',
      '    int capacity;',
      '} Bucket;',
      '',
      'void initBucket(Bucket* b, int initial_capacity) {',
      '    b->elements = (int*)malloc(initial_capacity * sizeof(int));',
      '    if (!b->elements && initial_capacity > 0) { exit(EXIT_FAILURE); }',
      '    b->count = 0;',
      '    b->capacity = initial_capacity;',
      '}',
      '',
      'void addToBucket(Bucket* b, int value) {',
      '    if (b->count == b->capacity) {',
      '        b->capacity = (b->capacity == 0) ? 1 : b->capacity * 2;',
      '        int* temp = (int*)realloc(b->elements, b->capacity * sizeof(int));',
      '        if (!temp) { free(b->elements); exit(EXIT_FAILURE); }',
      '        b->elements = temp;',
      '    }',
      '    b->elements[b->count++] = value;',
      '}',
      '',
      'void bucketSort(int arr[], int n, SortDirection direction, int numBucketsInput) {',
      '    if (n <= 1) return;',
      '',
      '    int minVal = arr[0];',
      '    int maxVal = arr[0];',
      '    for (int i = 1; i < n; i++) {',
      '        if (arr[i] < minVal) minVal = arr[i];',
      '        if (arr[i] > maxVal) maxVal = arr[i];',
      '    }',
      '',
      '    if (minVal == maxVal) return;',
      '',
      '    int numBuckets = (numBucketsInput > 0) ? numBucketsInput : n;',
      '    if (numBuckets <= 0) numBuckets = 1;',
      '',
      '    Bucket* buckets = (Bucket*)malloc(numBuckets * sizeof(Bucket));',
      '    if (!buckets) { exit(EXIT_FAILURE); }',
      '    for (int i = 0; i < numBuckets; i++) {',
      '        initBucket(&buckets[i], (n / numBuckets) + 1 > 0 ? (n / numBuckets) + 1 : 1);',
      '    }',
      '',
      '    double range = (double)maxVal - minVal;',
      '    double rangePerBucket = 1.0;',
      '    if (numBuckets > 1 && range > 0) {',
      '        rangePerBucket = (range + 1.0) / numBuckets;',
      '    } else if (numBuckets == 1) {',
      '        rangePerBucket = range + 1.0;',
      '    }',
      '',
      '    for (int i = 0; i < n; i++) {',
      '        int val = arr[i];',
      '        int bucketIndex = 0;',
      '        if (rangePerBucket > 0) {',
      '           bucketIndex = (int)floor((double)(val - minVal) / rangePerBucket);',
      '        }',
      '        ',
      '        if (val == maxVal && numBuckets > 1) {',
      '            bucketIndex = numBuckets - 1;',
      '        }',
      '        if (bucketIndex < 0) bucketIndex = 0;',
      '        if (bucketIndex >= numBuckets) bucketIndex = numBuckets - 1;',
      '        addToBucket(&buckets[bucketIndex], val);',
      '    }',
      '',
      '    for (int i = 0; i < numBuckets; i++) {',
      '        insertionSortForBucket(buckets[i].elements, buckets[i].count, direction);',
      '    }',
      '',
      '    int index = 0;',
      '    for (int i = 0; i < numBuckets; i++) {',
      '        for (int j = 0; j < buckets[i].count; j++) {',
      '            arr[index++] = buckets[i].elements[j];',
      '        }',
      '        free(buckets[i].elements);',
      '    }',
      '    free(buckets);',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <algorithm>',
      '#include <cmath>',
      '',
      'enum class SortDirection { ASC, DESC };',
      '',
      'void insertionSortForBucket(std::vector<int>& bucket, SortDirection direction) {',
      '    for (size_t i = 1; i < bucket.size(); ++i) {',
      '        int key = bucket[i];',
      '        int j = i - 1;',
      '        bool conditionMet;',
      '        if (direction == SortDirection::ASC) {',
      '            conditionMet = (j >= 0 && bucket[j] > key);',
      '        } else {',
      '            conditionMet = (j >= 0 && bucket[j] < key);',
      '        }',
      '        while (conditionMet) {',
      '            bucket[j + 1] = bucket[j];',
      '            j = j - 1;',
      '            if (j >= 0) {',
      '                 if (direction == SortDirection::ASC) conditionMet = (bucket[j] > key);',
      '                 else conditionMet = (bucket[j] < key);',
      '            } else {',
      '                conditionMet = false;',
      '            }',
      '        }',
      '        bucket[j + 1] = key;',
      '    }',
      '}',
      '',
      'void bucketSort(std::vector<int>& arr, SortDirection direction, int numBucketsInput = 0) {',
      '    int n = arr.size();',
      '    if (n <= 1) return;',
      '',
      '    int minVal = 0;',
      '    int maxVal = 0;',
      '    if (n > 0) {',
      '       minVal = arr[0];',
      '       maxVal = arr[0];',
      '       for (int x : arr) {',
      '           minVal = std::min(minVal, x);',
      '           maxVal = std::max(maxVal, x);',
      '       }',
      '    } else {',
      '        return;',
      '    }',
      '',
      '    if (minVal == maxVal) return;',
      '',
      '    int numBuckets = (numBucketsInput > 0) ? numBucketsInput : n;',
      '    if (numBuckets <= 0) numBuckets = 1;',
      '',
      '    std::vector<std::vector<int>> buckets(numBuckets);',
      '',
      '    double range = static_cast<double>(maxVal) - minVal;',
      '    double rangePerBucket = 1.0;',
      '    if (numBuckets > 1 && range > 0) {',
      '        rangePerBucket = (range + 1.0) / numBuckets;',
      '    } else if (numBuckets == 1) {',
      '        rangePerBucket = range + 1.0;',
      '    }',
      '',
      '    for (int val : arr) {',
      '        int bucketIndex = 0;',
      '        if (rangePerBucket > 0) {',
      '           bucketIndex = static_cast<int>(std::floor(static_cast<double>(val - minVal) / rangePerBucket));',
      '        }',
      '        ',
      '        if (val == maxVal && numBuckets > 1) {',
      '             bucketIndex = numBuckets - 1;',
      '        }',
      '        bucketIndex = std::max(0, std::min(bucketIndex, numBuckets - 1));',
      '        buckets[bucketIndex].push_back(val);',
      '    }',
      '',
      '    for (int i = 0; i < numBuckets; ++i) {',
      '        insertionSortForBucket(buckets[i], direction);',
      '    }',
      '',
      '    int index = 0;',
      '    for (int i = 0; i < numBuckets; ++i) {',
      '        for (int val : buckets[i]) {',
      '            arr[index++] = val;',
      '        }',
      '    }',
      '}',
    ],
    python: [
      'import math',
      '',
      'def insertion_sort_for_bucket(bucket, direction="asc"):',
      '    for i in range(1, len(bucket)):',
      '        key = bucket[i]',
      '        j = i - 1',
      '        condition_met = False',
      '        if direction == "asc":',
      '            if j >= 0 and bucket[j] > key:',
      '                condition_met = True',
      '        else:',
      '            if j >= 0 and bucket[j] < key:',
      '                condition_met = True',
      '        ',
      '        while condition_met:',
      '            bucket[j + 1] = bucket[j]',
      '            j -= 1',
      '            if j >= 0:',
      '                if direction == "asc":',
      '                    condition_met = bucket[j] > key',
      '                else:',
      '                    condition_met = bucket[j] < key',
      '            else:',
      '                condition_met = False',
      '        bucket[j + 1] = key',
      '    return bucket',
      '',
      'def bucket_sort(arr, direction="asc", num_buckets_input=None):',
      '    n = len(arr)',
      '    if n <= 1:',
      '        return arr',
      '',
      '    min_val = min(arr) if n > 0 else 0',
      '    max_val = max(arr) if n > 0 else 0',
      '',
      '    if min_val == max_val:',
      '        return arr',
      '',
      '    num_buckets = num_buckets_input if num_buckets_input is not None and num_buckets_input > 0 else n',
      '    if num_buckets <= 0: num_buckets = 1',
      '',
      '    buckets = [[] for _ in range(num_buckets)]',
      '',
      '    range_val = float(max_val - min_val)',
      '    range_per_bucket = 1.0',
      '    if num_buckets > 1 and range_val >= 0: # range_val can be 0 if all elements are same but min_val != max_val (float precision)',
      '        range_per_bucket = (range_val + 1.0) / num_buckets',
      '    elif num_buckets == 1:',
      '        range_per_bucket = range_val + 1.0',
      '    if range_per_bucket == 0: range_per_bucket = 1.0 # Avoid division by zero if all elements are identical after all',
      '',
      '    for val in arr:',
      '        bucket_index = 0',
      '        if range_per_bucket > 0:',
      '            bucket_index = math.floor((val - min_val) / range_per_bucket)',
      '        ',
      '        if val == max_val and num_buckets > 1: ',
      '            bucket_index = num_buckets - 1',
      '        bucket_index = max(0, min(bucket_index, num_buckets - 1))',
      '        buckets[bucket_index].append(val)',
      '',
      '    index = 0',
      '    # arr will be reconstructed, so direct assignment or extend is fine',
      '    # Create a new list for arr to avoid modifying it while iterating through buckets derived from it, though python copies values',
      '    arr[:] = [] # Clear the original array to rebuild it',
      '    for i in range(num_buckets):',
      '        insertion_sort_for_bucket(buckets[i], direction)',
      '        for item in buckets[i]:',
      '            arr.append(item) # Rebuild arr',
      '',
      '    return arr',
    ],
  },
  pseudoCodeMapping: {
    // PT Line: New Plaintext Line Number
    // Original PT Line -> New PT Line (0-indexed)
    // 0 -> 0: procedure bucketSort(list, direction, numBuckets)
    0: { c: [50], cpp: [28], python: [28] },
    // 1 -> 1:   if length of list <= 1 then return list
    1: { c: [51], cpp: [30], python: [30] },
    // 2 -> 2:   minVal = findMinValue(list)
    2: { c: [53, 55], cpp: [32, 35], python: [33] }, // C covers loop, Cpp std::min/max, Py min()
    // 3 -> 3:   maxVal = findMaxValue(list)
    3: { c: [54, 55], cpp: [33, 35], python: [34] }, // C covers loop, Cpp std::min/max, Py max()
    // 4 -> 4:   if minVal == maxVal then return list
    4: { c: [58], cpp: [40], python: [37] },
    // Original 8 -> New 6:   if numBuckets is not specified then numBuckets = length of list
    6: { c: [60], cpp: [42], python: [40] },
    // Original 9 -> New 7:   if numBuckets <= 0 then numBuckets = 1
    7: { c: [61], cpp: [43], python: [41] },
    // Original 11 -> New 9:   create numBuckets empty buckets
    9: { c: [63, 64, 65, 66], cpp: [45], python: [43] }, // C covers malloc loop, Cpp/Py direct
    // Original 12 (text part) -> New 10:   rangePerBucket = (maxVal - minVal + 1.0) / numBuckets
    10: { c: [68, 69, 70, 71, 72], cpp: [47, 48, 49, 50, 51], python: [45, 46, 47, 48] }, // Covers range and rangePerBucket logic
    // Original 14 -> New 12:   for each element in list
    12: { c: [74], cpp: [53], python: [50] },
    // Original 17 -> New 13:     bucketIndex = floor((element - minVal) / rangePerBucket)
    13: { c: [76, 77, 78], cpp: [54, 55, 56], python: [51, 52, 53] }, // Covers val, bucketIndex calc
    // Original 18 -> New 14:     if element == maxVal then bucketIndex = numBuckets - 1
    14: { c: [80], cpp: [58], python: [55] },
    // Original 19 -> New 15:     bucketIndex = max(0, min(bucketIndex, numBuckets - 1))
    15: { c: [81, 82], cpp: [59], python: [56] },
    // Original 20 -> New 16:     add element to buckets[bucketIndex]
    16: { c: [83], cpp: [60], python: [57] },
    // Original 21 -> New 17:   end for (scatter loop)
    17: { c: [84], cpp: [61], python: [58] },
    // Original 23 -> New 19:   for each bucket in buckets
    19: { c: [86], cpp: [63], python: [63] },
    // Original 24 -> New 20:     insertionSort(bucket, direction)
    20: { c: [87], cpp: [64], python: [64] },
    // Original 25 -> New 21:   end for (bucket sorting loop)
    21: { c: [88], cpp: [65], python: [66] }, // Python appends in this loop
    // Original 27 -> New 23:   index = 0
    23: { c: [90], cpp: [67], python: [59] }, // Python uses list.append, so index is implicit or arr is cleared
    // Original 28 -> New 24:   for each bucket in buckets (gather loop)
    24: { c: [91], cpp: [68], python: [63] },
    // Original 29 -> New 25:     for each element in bucket
    25: { c: [92], cpp: [69], python: [65] },
    // Original 30 -> New 26:       list[index] = element
    26: { c: [93], cpp: [70], python: [66] },
    // Original 31 -> New 27:       index = index + 1
    27: { c: [93], cpp: [70], python: [66] }, // Increment is part of same line in C/Cpp
    // Original 32 -> New 28:     end for (inner gather)
    28: { c: [94], cpp: [71], python: [66] },
    // Original 33 -> New 29:   end for (outer gather)
    29: { c: [96], cpp: [72], python: [67] },
    // Original 35 -> New 31:   return list
    31: { c: [97], cpp: [73], python: [68] }, // Python returns arr
    // Original 36 -> New 32: end procedure
    32: { c: [97], cpp: [73], python: [68] },

    // Insertion Sort Helper
    // Original 38 -> New 34: procedure insertionSort(bucket, direction)
    34: { c: [8], cpp: [6], python: [2] },
    // Original 39 -> New 35:   for i = 1 to length of bucket - 1
    35: { c: [9], cpp: [7], python: [3] },
    // Original 40 -> New 36:     key = bucket[i]
    36: { c: [10], cpp: [8], python: [4] },
    // Original 41 -> New 37:     j = i - 1
    37: { c: [11], cpp: [9], python: [5] },
    // Original 42 -> New 38:     while j >= 0 and ((direction == ASC and bucket[j] > key) or (direction == DESC and bucket[j] < key))
    38: {
      c: [13, 14, 15, 16, 17, 18],
      cpp: [11, 12, 13, 14, 15, 16],
      python: [7, 8, 9, 10, 11, 12, 14],
    }, // Covers conditionMet and while
    // Original 43 -> New 39:       bucket[j + 1] = bucket[j]
    39: { c: [19], cpp: [17], python: [15] },
    // Original 44 -> New 40:       j = j - 1
    40: { c: [20], cpp: [18], python: [16] },
    // Original 45 -> New 41:     end while
    41: { c: [26], cpp: [24], python: [23] }, // End of Python while block
    // Original 46 -> New 42:     bucket[j + 1] = key
    42: { c: [27], cpp: [25], python: [24] },
    // Original 47 -> New 43:   end for
    43: { c: [28], cpp: [26], python: [25] },
    // Original 48 -> New 44: end procedure
    44: { c: [29], cpp: [27], python: [26] },
  },
  hasAdvancedAuxiliaryVisuals: true,
}
