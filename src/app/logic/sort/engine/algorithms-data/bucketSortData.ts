import type { SortAlgorithm } from '../algorithmRegistry'

const rawPlaintextPseudoCode = [
  'procedure bucketSort(list, direction, numBuckets)',
  '  if length of list <= 1 then return list',
  '  minVal = findMinValue(list)',
  '  maxVal = findMaxValue(list)',
  '  if minVal == maxVal then return list',
  '',
  '  if numBuckets is not specified then numBuckets = length of list',
  '  if numBuckets <= 0 then numBuckets = 1',
  '',
  '  create numBuckets empty buckets',
  '  rangePerBucket = (maxVal - minVal + 1.0) / numBuckets',
  '',
  '  for each element in list',
  '    bucketIndex = floor((element - minVal) / rangePerBucket)',
  '    if element == maxVal then bucketIndex = numBuckets - 1',
  '    bucketIndex = max(0, min(bucketIndex, numBuckets - 1))',
  '    add element to buckets[bucketIndex]',
  '  end for',
  '',
  '  for each bucket in buckets',
  '    insertionSort(bucket, direction)',
  '  end for',
  '',
  '  index = 0',
  '  for each bucket in buckets',
  '    for each element in bucket',
  '      list[index] = element',
  '      index = index + 1',
  '    end for',
  '  end for',
  '',
  '  return list',
  'end procedure',
  '',
  'procedure insertionSort(bucket, direction)',
  '  for i = 1 to length of bucket - 1',
  '    key = bucket[i]',
  '    j = i - 1',
  '    while j >= 0 and ((direction == ASC and bucket[j] > key) or (direction == DESC and bucket[j] < key))',
  '      bucket[j + 1] = bucket[j]',
  '      j = j - 1',
  '    end while',
  '    bucket[j + 1] = key',
  '  end for',
  'end procedure',
]

export const bucketSortData: SortAlgorithm = {
  id: 'bucketSort',
  name: 'Bucket Sort',
  description:
    'Bucket Sort is a distribution sort algorithm that works by distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm, or by recursively applying the bucket sort algorithm. It is most effective when the input data is uniformly distributed over a range. The efficiency of Bucket Sort depends on the number of buckets and the algorithm used to sort the buckets.',
  complexity: {
    time: { best: 'O(n+k)', average: 'O(n+k)', worst: 'O(n^2)' },
    space: 'O(n+k)',
  },
  origin: { name: 'Historical concept, refined over time', year: 'Known since 1940s/50s' },
  img: '',
  pseudoCode: rawPlaintextPseudoCode,
  languageExamples: {
    c: [
      '#include <stdio.h>',
      '#include <stdlib.h>',
      '#include <stdbool.h>',
      '#include <math.h>',
      '',
      'void insertionSortForBucket(int bucket[], int n_bucket, bool ascending) {',
      '    if (n_bucket <= 1) return;',
      '    for (int i = 1; i < n_bucket; i++) {',
      '        int key = bucket[i];',
      '        int j = i - 1;',
      '        bool condition;',
      '        if (ascending) {',
      '            condition = (j >= 0 && bucket[j] > key);',
      '        } else {',
      '            condition = (j >= 0 && bucket[j] < key);',
      '        }',
      '        while (condition) {',
      '            bucket[j + 1] = bucket[j];',
      '            j--;',
      '            if (ascending) {',
      '                condition = (j >= 0 && bucket[j] > key);',
      '            } else {',
      '                condition = (j >= 0 && bucket[j] < key);',
      '            }',
      '        }',
      '        bucket[j + 1] = key;',
      '    }',
      '}',
      '',
      'void bucketSort(int arr[], int n, bool ascending) {',
      '    if (n <= 1) return;',
      '',
      '    int minVal = arr[0];',
      '    int maxVal = arr[0];',
      '    for (int i = 1; i < n; i++) {',
      '        if (arr[i] < minVal) minVal = arr[i];',
      '        if (arr[i] > maxVal) maxVal = arr[i];',
      '    }',
      '',
      '    if (minVal == maxVal) return;',
      '',
      '    int numBuckets = n;',
      '',
      '    typedef struct {',
      '        int* elements;',
      '        int count;',
      '    } Bucket;',
      '',
      '    Bucket* buckets = (Bucket*)malloc(numBuckets * sizeof(Bucket));',
      '    if (!buckets) return;',
      '    for (int i = 0; i < numBuckets; i++) {',
      '        buckets[i].elements = (int*)malloc(n * sizeof(int));',
      '        if (!buckets[i].elements) {',
      '            for(int k=0; k<i; ++k) free(buckets[k].elements); free(buckets); return;',
      '        }',
      '        buckets[i].count = 0;',
      '    }',
      '',
      '    double rangePerBucket = (double)(maxVal - minVal + 1.0) / numBuckets;',
      '',
      '    for (int i = 0; i < n; i++) {',
      '        int element = arr[i];',
      '        int bucketIndex = 0;',
      '        if (rangePerBucket > 1e-9) { ',
      '             bucketIndex = (int)floor((element - minVal) / rangePerBucket);',
      '        }',
      '       ',
      '        if (element == maxVal && numBuckets > 1) {',
      '            bucketIndex = numBuckets - 1;',
      '        }',
      '        if (bucketIndex < 0) bucketIndex = 0;',
      '        if (bucketIndex >= numBuckets) bucketIndex = numBuckets - 1;',
      '        ',
      '        buckets[bucketIndex].elements[buckets[bucketIndex].count++] = element;',
      '    }',
      '',
      '    for (int i = 0; i < numBuckets; i++) {',
      '        insertionSortForBucket(buckets[i].elements, buckets[i].count, ascending);',
      '    }',
      '',
      '    int index = 0;',
      '    for (int i = 0; i < numBuckets; i++) {',
      '        for (int j = 0; j < buckets[i].count; j++) {',
      '            arr[index++] = buckets[i].elements[j];',
      '        }',
      '        free(buckets[i].elements);',
      '    }',
      '    free(buckets);',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <algorithm>',
      '#include <cmath>',
      '',
      'template <typename T>',
      'void insertionSortForBucket(std::vector<T>& bucket, bool ascending) {',
      '    if (bucket.empty()) return;',
      '    for (size_t i = 1; i < bucket.size(); ++i) {',
      '        T key = bucket[i];',
      '        long j = i - 1;',
      '        if (ascending) {',
      '            while (j >= 0 && bucket[j] > key) {',
      '                bucket[j + 1] = bucket[j];',
      '                --j;',
      '            }',
      '        } else {',
      '            while (j >= 0 && bucket[j] < key) {',
      '                bucket[j + 1] = bucket[j];',
      '                --j;',
      '            }',
      '        }',
      '        bucket[j + 1] = key;',
      '    }',
      '}',
      '',
      'template <typename T>',
      'void bucketSort(std::vector<T>& arr, bool ascending) {',
      '    int n = arr.size();',
      '    if (n <= 1) return;',
      '',
      '    auto mm = std::minmax_element(arr.begin(), arr.end());',
      '    T minVal = *mm.first;',
      '    T maxVal = *mm.second;',
      '',
      '    if (minVal == maxVal) return;',
      '',
      '    int numBuckets = n;',
      '    ',
      '    std::vector<std::vector<T>> buckets(numBuckets);',
      '',
      '    double rangePerBucket = static_cast<double>(maxVal - minVal + 1.0) / numBuckets;',
      '    if (rangePerBucket <= 1e-9 && numBuckets > 0) { ',
      '         rangePerBucket = 1.0;',
      '    }',
      '',
      '    for (int i = 0; i < n; ++i) {',
      '        T element = arr[i];',
      '        int bucketIndex = 0;',
      '        if (rangePerBucket > 1e-9) {',
      '             bucketIndex = static_cast<int>(std::floor((element - minVal) / rangePerBucket));',
      '        }',
      '        ',
      '        if (element == maxVal && numBuckets > 1) {',
      '             bucketIndex = numBuckets - 1;',
      '        }',
      '        bucketIndex = std::max(0, std::min(bucketIndex, numBuckets - 1));',
      '        ',
      '        buckets[bucketIndex].push_back(element);',
      '    }',
      '',
      '    for (int i = 0; i < numBuckets; ++i) {',
      '        insertionSortForBucket(buckets[i], ascending);',
      '    }',
      '',
      '    int index = 0;',
      '    for (int i = 0; i < numBuckets; ++i) {',
      '        for (const T& element : buckets[i]) {',
      '            arr[index++] = element;',
      '        }',
      '    }',
      '}',
    ],
    python: [
      'def insertionSortForBucket(bucket, ascending=True):',
      '    if len(bucket) <= 1:',
      '        return',
      '    for i in range(1, len(bucket)):',
      '        key = bucket[i]',
      '        j = i - 1',
      '        if ascending:',
      '            condition = (j >= 0 and bucket[j] > key)',
      '        else:',
      '            condition = (j >= 0 and bucket[j] < key)',
      '        while condition:',
      '            bucket[j + 1] = bucket[j]',
      '            j -= 1',
      '            if ascending:',
      '                condition = (j >= 0 and bucket[j] > key)',
      '            else:',
      '                condition = (j >= 0 and bucket[j] < key)',
      '        bucket[j + 1] = key',
      '',
      'def bucketSort(arr, ascending=True, numBucketsParam=None):',
      '    n = len(arr)',
      '    if n <= 1:',
      '        return arr',
      '',
      '    min_val = min(arr)',
      '    max_val = max(arr)',
      '',
      '    if min_val == max_val:',
      '        return arr',
      '',
      '    if numBucketsParam is None:',
      '        num_buckets = n',
      '    else:',
      '        num_buckets = numBucketsParam',
      '    ',
      '    if num_buckets <= 0:',
      '        num_buckets = 1',
      '',
      '    buckets = [[] for _ in range(num_buckets)]',
      '    ',
      '    value_span = (max_val - min_val)',
      '    if value_span == 0:',
      '        range_per_bucket = 1.0 ',
      '    else:',
      '        range_per_bucket = (float(value_span) + 1.0) / num_buckets',
      '',
      '    for element in arr:',
      '        bucket_index = 0',
      '        if range_per_bucket > 1e-9:',
      '             bucket_index = int((element - min_val) / range_per_bucket)',
      '        ',
      '        if element == max_val and num_buckets > 1:',
      '            bucket_index = num_buckets - 1',
      '            ',
      '        bucket_index = max(0, min(bucket_index, num_buckets - 1))',
      '        ',
      '        buckets[bucket_index].append(element)',
      '',
      '    for i in range(num_buckets):',
      '        insertionSortForBucket(buckets[i], ascending)',
      '',
      '    index = 0',
      '    for i in range(num_buckets):',
      '        for element in buckets[i]:',
      '            arr[index] = element',
      '            index += 1',
      '    return arr',
    ],
  },
  pseudoCodeMapping: {
    0: { c: [29], cpp: [30], python: [23] },
    1: { c: [30], cpp: [32], python: [25] },
    2: { c: [32, 34], cpp: [34], python: [28] },
    3: { c: [33, 34], cpp: [35], python: [29] },
    4: { c: [38], cpp: [37], python: [31] },
    6: { c: [40], cpp: [39], python: [33] },
    7: { c: [40], cpp: [39], python: [38] },
    9: { c: [47, 52], cpp: [43], python: [41] },
    10: { c: [54], cpp: [45], python: [45] },
    12: { c: [57], cpp: [50], python: [50] },
    13: { c: [61], cpp: [54], python: [54] },
    14: { c: [64], cpp: [57], python: [57] },
    15: { c: [67], cpp: [60], python: [60] },
    16: { c: [70], cpp: [62], python: [62] },
    17: { c: [71], cpp: [63], python: [63] },
    19: { c: [74], cpp: [66], python: [65] },
    20: { c: [75], cpp: [68], python: [66] },
    21: { c: [76], cpp: [72], python: [67] },
    23: { c: [79], cpp: [75], python: [69] },
    24: { c: [80], cpp: [76], python: [70] },
    25: { c: [81], cpp: [77], python: [71] },
    26: { c: [82], cpp: [78], python: [72] },
    27: { c: [82], cpp: [78], python: [73] },
    28: { c: [83], cpp: [79], python: [74] },
    29: { c: [85], cpp: [80], python: [75] },
    31: { c: [86], cpp: [81], python: [77] },
    32: { c: [86], cpp: [81], python: [78] },
    34: { c: [6], cpp: [6], python: [1] },
    35: { c: [8], cpp: [8], python: [4] },
    36: { c: [9], cpp: [9], python: [5] },
    37: { c: [10], cpp: [10], python: [6] },
    38: { c: [11, 16], cpp: [11, 16], python: [7, 12] },
    39: { c: [17], cpp: [17], python: [13] },
    40: { c: [18], cpp: [18], python: [14] },
    41: { c: [23], cpp: [23], python: [19] },
    42: { c: [24], cpp: [24], python: [20] },
    43: { c: [25], cpp: [25], python: [21] },
    44: { c: [26], cpp: [26], python: [21] },
  },
  performancePaths: {
    best: [
      0, 1, 2, 3, 4, 6, 7, 9, 10, 12, 13, 15, 16, 17, 19, 20, 21, 23, 24, 25, 26, 27, 28, 29, 31,
      32, 34, 35, 43, 44,
    ],
    average: [
      0, 1, 2, 3, 4, 6, 7, 9, 10, 12, 13, 14, 15, 16, 17, 19, 20, 21, 23, 24, 25, 26, 27, 28, 29,
      31, 32, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,
    ],
    worst: [
      0, 1, 2, 3, 4, 6, 7, 9, 10, 12, 13, 14, 15, 16, 17, 19, 20, 21, 23, 24, 25, 26, 27, 28, 29,
      31, 32, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,
    ],
  },
}
