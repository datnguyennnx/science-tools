'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { bucketSortGenerator } from '../algorithms'

export const bucketSortData: SortAlgorithm = {
  id: 'bucketSort',
  name: 'Bucket Sort',
  description:
    'Bucket Sort, also known as bin sort, is a distribution sort algorithm that divides the input elements into a number of buckets. Each bucket is then sorted independently, either using a different sorting algorithm or by recursively applying the bucket sorting algorithm. It works best when the input data is uniformly distributed over a range. The motivation is to distribute the sorting effort across multiple smaller sorting problems, which can lead to better average-case performance than comparison sorts for certain data distributions.',
  generator: bucketSortGenerator,
  complexity: {
    time: { best: 'O(n + k)', average: 'O(n + k)', worst: 'O(n^2)' },
    space: 'O(n + k)',
  },
  origin: { name: 'Distribution-based / Early' },
  img: '',
  pseudoCodes: {
    plaintext: [
      'procedure bucketSort(list, numBuckets)',
      '  if length of list <= 1 or numBuckets <= 0 then return list // Or handle error',
      '',
      '  minVal = findMinValue(list)',
      '  maxVal = findMaxValue(list)',
      '',
      '  if minVal == maxVal then return list // All elements are same or list has one distinct element',
      '',
      '  // Calculate the range for each bucket',
      '  rangePerBucket = (maxVal - minVal) / numBuckets',
      '  if rangePerBucket == 0 then rangePerBucket = 1 // Avoid division by zero or non-progress if numBuckets is very large',
      '',
      '  create numBuckets empty buckets // Each bucket is typically a list',
      '',
      '  // Distribute input elements into buckets',
      '  for each element in list',
      '    bucketIndex = floor((element - minVal) / rangePerBucket)',
      "    // Clamp bucketIndex to ensure it's within [0, numBuckets - 1]",
      '    if bucketIndex < 0 then bucketIndex = 0',
      '    if bucketIndex >= numBuckets then bucketIndex = numBuckets - 1',
      '    add element to buckets[bucketIndex]',
      '  end for',
      '',
      '  // Sort each bucket individually',
      '  for each bucket in buckets',
      '    insertionSort(bucket) // Or any other suitable sorting algorithm',
      '  end for',
      '',
      '  // Concatenate sorted buckets to get the final sorted list',
      '  index = 0',
      '  for each bucket in buckets',
      '    for each element in bucket',
      '      list[index] = element',
      '      index = index + 1',
      '    end for',
      '  end for',
      '  // list is now sorted in-place, or procedure could return a new sorted list',
      'end procedure',
    ],
    c: [
      '#include <math.h> // For floor',
      '#include <stdlib.h> // For malloc (if using dynamic buckets)',
      '// Assumes: void insertionSortForBuckets(int arr[], int n); exists for sorting buckets.',
      '',
      'void bucketSort(int arr[], int n, int numBuckets) {',
      '  if (n <= 0 || numBuckets <= 0) return;',
      '',
      '  int minVal = arr[0], maxVal = arr[0];',
      '  for (int i = 1; i < n; i++) {',
      '    if (arr[i] < minVal) minVal = arr[i];',
      '    if (arr[i] > maxVal) maxVal = arr[i];',
      '  }',
      '',
      '  if (minVal == maxVal) return; // All elements are the same',
      '',
      '  // Using VLA for bucket storage in this example for simplicity.',
      '  // Not standard C for all compilers & can be risky for large numBuckets or n.',
      '  // A robust C version uses dynamic arrays (e.g., array of linked lists or allocated arrays).',
      '  int buckets[numBuckets][n]; // Max n elements per bucket (worst-case assumption)',
      '  int bucketCounts[numBuckets];',
      '  for (int i = 0; i < numBuckets; i++) {',
      '    bucketCounts[i] = 0;',
      '  }',
      '',
      '  double rangeVal = (double)(maxVal - minVal) / numBuckets;',
      '  if (rangeVal == 0) rangeVal = 1.0; // Avoid division by zero / ensure distribution',
      '',
      '  for (int i = 0; i < n; i++) {',
      '    int bucketIndex = floor((arr[i] - minVal) / rangeVal);',
      '    if (bucketIndex < 0) bucketIndex = 0;',
      '    if (bucketIndex >= numBuckets) bucketIndex = numBuckets - 1;',
      '    // Ensure bucketCounts[bucketIndex] < n if using fixed size buckets[numBuckets][n]',
      '    if (bucketCounts[bucketIndex] < n) { // Basic check to prevent overflow for fixed size',
      '        buckets[bucketIndex][bucketCounts[bucketIndex]++] = arr[i];',
      '    } else {',
      '        // Handle bucket overflow if not using dynamic buckets - this example might lose data',
      '    }',
      '  }',
      '',
      '  int index = 0;',
      '  for (int i = 0; i < numBuckets; i++) {',
      '    if (bucketCounts[i] > 0) {',
      '      insertionSortForBuckets(buckets[i], bucketCounts[i]); // Sort each bucket',
      '      for (int j = 0; j < bucketCounts[i]; j++) {',
      '        arr[index++] = buckets[i][j];',
      '      }',
      '    }',
      '  }',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <algorithm> // For std::min_element, std::max_element, std::sort',
      '#include <cmath>   // For std::floor',
      '',
      'void bucketSort(std::vector<float>& arr, int numBuckets) {',
      '  if (arr.empty() || numBuckets <= 0) return;',
      '',
      '  float minVal = arr[0], maxVal = arr[0];',
      '  if (arr.size() > 1) { // To avoid accessing arr[0] on empty after check',
      '      minVal = *std::min_element(arr.begin(), arr.end());',
      '      maxVal = *std::max_element(arr.begin(), arr.end());',
      '  } else if (!arr.empty()) { // Single element list',
      '      minVal = maxVal = arr[0];',
      '  } // else arr.empty() handled by first if',
      '',
      '  if (minVal == maxVal) {',
      '    return; // Already sorted or all elements are the same',
      '  }',
      '',
      '  std::vector<std::vector<float>> buckets(numBuckets);',
      '  // Use double for range calculation to maintain precision before casting to int for index',
      '  double range_calc = static_cast<double>(maxVal - minVal) / numBuckets;',
      '  if (range_calc == 0) range_calc = 1.0; // Avoid division by zero or ensure distribution',
      '',
      '  for (float val : arr) {',
      '    int bucketIndex = static_cast<int>(std::floor((val - minVal) / range_calc));',
      '    if (bucketIndex < 0) bucketIndex = 0;',
      '    if (bucketIndex >= numBuckets) bucketIndex = numBuckets - 1;',
      '    buckets[bucketIndex].push_back(val);',
      '  }',
      '',
      '  int index = 0;',
      '  for (int i = 0; i < numBuckets; i++) {',
      '    std::sort(buckets[i].begin(), buckets[i].end()); // Example: using std::sort for buckets',
      '    for (float val : buckets[i]) {',
      '      arr[index++] = val;',
      '    }',
      '  }',
      '}',
    ],
    python: [
      'def insertion_sort_simple(bucket):',
      '    for i in range(1, len(bucket)):',
      '        key = bucket[i]',
      '        j = i - 1',
      '        while j >= 0 and bucket[j] > key:',
      '            bucket[j + 1] = bucket[j]',
      '            j -= 1',
      '        bucket[j + 1] = key',
      '    return bucket',
      '',
      'def bucket_sort(arr, num_buckets):',
      '    if not arr or num_buckets <= 0:',
      '        return arr',
      '',
      '    min_val, max_val = min(arr), max(arr)',
      '    if min_val == max_val:',
      '        return arr',
      '',
      '    buckets = [[] for _ in range(num_buckets)]',
      '    # Calculate range ensuring it is at least 1 to avoid division by zero if max_val == min_val (already handled) or num_buckets is too large',
      '    bucket_range = (max_val - min_val) / num_buckets',
      '    if bucket_range == 0: bucket_range = 1.0',
      '',
      '    for x in arr:',
      '        index = int((x - min_val) / bucket_range)',
      '        if index >= num_buckets:',
      '            index = num_buckets - 1',
      '        elif index < 0:',
      '            index = 0',
      '        buckets[index].append(x)',
      '',
      '    sorted_arr = [] # Python version typically returns a new list',
      '    for bucket in buckets:',
      '        # bucket.sort() # Using built-in sort for buckets',
      '        insertion_sort_simple(bucket) # Or using the provided insertion sort',
      '        sorted_arr.extend(bucket)',
      '',
      '    # To modify original array in place (if preferred):',
      '    # for i in range(len(arr)):',
      '    #     arr[i] = sorted_arr[i]',
      '    # return',
      '    return sorted_arr',
    ],
  },
  hasAdvancedAuxiliaryVisuals: true,
}
