'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { cycleSortGenerator } from '../algorithms'

export const cycleSortData: SortAlgorithm = {
  id: 'cycleSort',
  name: 'Cycle Sort',
  description:
    'Cycle Sort is an in-place sorting algorithm that is optimal in terms of the number of writes to the original array. It is based on the idea of permutations and cycles. For each element, it finds its correct position in the sorted array and rotates the elements that are in the way to complete a cycle. This minimizes writes because each element is written at most once to its final sorted position. While it has a worst-case time complexity of O(n^2), its focus on minimizing writes makes it suitable for scenarios where writes are significantly more expensive than reads.',
  generator: cycleSortGenerator,
  complexity: { time: { best: 'O(n^2)', average: 'O(n^2)', worst: 'O(n^2)' }, space: 'O(1)' },
  origin: { name: 'J.P. Black & P.J.P. Taylor', year: 1990 },
  img: '',
  pseudoCodes: {
    plaintext: [
      'procedure cycleSort(list, direction)',
      '  n = length of list',
      '  for cycleStart = 0 to n - 2',
      '    itemInHand = list[cycleStart]',
      '    pos = cycleStart',
      '    for i = cycleStart + 1 to n - 1',
      '      if (direction == ASC and list[i] < itemInHand) or (direction == DESC and list[i] > itemInHand) then',
      '        pos = pos + 1',
      '      end if',
      '    end for',
      '',
      '    if pos == cycleStart then',
      '      continue',
      '    end if',
      '',
      '    while itemInHand == list[pos]',
      '      pos = pos + 1',
      '    end while',
      '',
      '    if pos != cycleStart then',
      '      swap itemInHand with list[pos]',
      '    end if',
      '',
      '    while pos != cycleStart',
      '      pos = cycleStart',
      '      for i = cycleStart + 1 to n - 1',
      '        if (direction == ASC and list[i] < itemInHand) or (direction == DESC and list[i] > itemInHand) then',
      '          pos = pos + 1',
      '        end if',
      '      end for',
      '',
      '      while itemInHand == list[pos]',
      '        pos = pos + 1',
      '      end while',
      '',
      '      if itemInHand != list[pos] then',
      '        swap itemInHand with list[pos]',
      '      end if',
      '    end while',
      '  end for',
      'end procedure',
    ],
    c: [
      '#include <stdbool.h>',
      '',
      'typedef enum { ASC, DESC } SortDirection;',
      '',
      'void cycleSort(int arr[], int n, SortDirection direction) {',
      '  if (n <= 1) return;',
      '  for (int cycle_start = 0; cycle_start <= n - 2; cycle_start++) {',
      '    int item = arr[cycle_start];',
      '    int pos = cycle_start;',
      '    for (int i = cycle_start + 1; i < n; i++) {',
      '      bool conditionMet = false;',
      '      if (direction == ASC && arr[i] < item) conditionMet = true;',
      '      else if (direction == DESC && arr[i] > item) conditionMet = true;',
      '      if (conditionMet) {',
      '        pos++;',
      '      }',
      '    }',
      '',
      '    if (pos == cycle_start) {',
      '      continue;',
      '    }',
      '',
      '    while (item == arr[pos]) {',
      '      pos++;',
      '    }',
      '',
      '    if (pos != cycle_start) {',
      '      int temp_holder = item;',
      '      item = arr[pos];',
      '      arr[pos] = temp_holder;',
      '    }',
      '',
      '    while (pos != cycle_start) {',
      '      pos = cycle_start;',
      '      for (int i = cycle_start + 1; i < n; i++) {',
      '        bool conditionMet = false;',
      '        if (direction == ASC && arr[i] < item) conditionMet = true;',
      '        else if (direction == DESC && arr[i] > item) conditionMet = true;',
      '        if (conditionMet) {',
      '          pos++;',
      '        }',
      '      }',
      '',
      '      while (item == arr[pos]) {',
      '        pos++;',
      '      }',
      '',
      '      if (item != arr[pos]) {',
      '        int temp_holder = item;',
      '        item = arr[pos];',
      '        arr[pos] = temp_holder;',
      '      }',
      '    }',
      '  }',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <algorithm>',
      '',
      'enum class SortDirection { ASC, DESC };',
      '',
      'void cycleSort(std::vector<int>& arr, SortDirection direction) {',
      '  int n = arr.size();',
      '  if (n <= 1) return;',
      '  for (int cycle_start = 0; cycle_start <= n - 2; cycle_start++) {',
      '    int item = arr[cycle_start];',
      '    int pos = cycle_start;',
      '    for (int i = cycle_start + 1; i < n; i++) {',
      '      bool conditionMet = false;',
      '      if (direction == SortDirection::ASC && arr[i] < item) conditionMet = true;',
      '      else if (direction == SortDirection::DESC && arr[i] > item) conditionMet = true;',
      '      if (conditionMet) {',
      '        pos++;',
      '      }',
      '    }',
      '',
      '    if (pos == cycle_start) {',
      '      continue;',
      '    }',
      '',
      '    while (item == arr[pos]) {',
      '      pos++;',
      '    }',
      '',
      '    if (pos != cycle_start) {',
      '      std::swap(item, arr[pos]);',
      '    }',
      '',
      '    while (pos != cycle_start) {',
      '      pos = cycle_start;',
      '      for (int i = cycle_start + 1; i < n; i++) {',
      '        bool conditionMet = false;',
      '        if (direction == SortDirection::ASC && arr[i] < item) conditionMet = true;',
      '        else if (direction == SortDirection::DESC && arr[i] > item) conditionMet = true;',
      '        if (conditionMet) {',
      '          pos++;',
      '        }',
      '      }',
      '',
      '      while (item == arr[pos]) {',
      '        pos++;',
      '      }',
      '',
      '      if (item != arr[pos]) {',
      '        std::swap(item, arr[pos]);',
      '      }',
      '    }',
      '  }',
      '}',
    ],
    python: [
      'def cycle_sort(arr, direction="asc"):',
      '    n = len(arr)',
      '    if n <= 1: return arr',
      '    for cycle_start in range(n - 1):',
      '        item = arr[cycle_start]',
      '        pos = cycle_start',
      '        for i in range(cycle_start + 1, n):',
      '            condition_met = False',
      '            if direction == "asc" and arr[i] < item: condition_met = True',
      '            elif direction == "desc" and arr[i] > item: condition_met = True',
      '            if condition_met:',
      '                pos += 1',
      '',
      '        if pos == cycle_start:',
      '            continue',
      '',
      '        while item == arr[pos]:',
      '            pos += 1',
      '',
      '        if pos != cycle_start:',
      '            arr[pos], item = item, arr[pos]',
      '',
      '        while pos != cycle_start:',
      '            pos = cycle_start',
      '            for i in range(cycle_start + 1, n):',
      '                condition_met = False',
      '                if direction == "asc" and arr[i] < item: condition_met = True',
      '                elif direction == "desc" and arr[i] > item: condition_met = True',
      '                if condition_met:',
      '                    pos += 1',
      '',
      '            while item == arr[pos]:',
      '                pos += 1',
      '',
      '            if item != arr[pos]:',
      '                arr[pos], item = item, arr[pos]',
      '    return arr',
    ],
  },
  pseudoCodeMapping: {
    0: { c: [4], cpp: [5], python: [0] },
    1: { c: [5], cpp: [7], python: [1] },
    2: { c: [6], cpp: [8], python: [3] },
    3: { c: [7], cpp: [9], python: [4] },
    4: { c: [8], cpp: [10], python: [5] },
    5: { c: [9], cpp: [11], python: [6] },
    6: { c: [11, 12, 13], cpp: [13, 14, 15], python: [8, 9, 10] },
    7: { c: [14], cpp: [16], python: [11] },
    8: { c: [15], cpp: [17], python: [11] },
    9: { c: [16], cpp: [18], python: [12] },
    11: { c: [18], cpp: [20], python: [13] },
    12: { c: [19], cpp: [21], python: [14] },
    13: { c: [20], cpp: [22], python: [14] },
    15: { c: [22], cpp: [24], python: [16] },
    16: { c: [23], cpp: [25], python: [17] },
    17: { c: [24], cpp: [26], python: [17] },
    19: { c: [26], cpp: [28], python: [19] },
    20: { c: [27, 28, 29], cpp: [29, 30, 31], python: [20] },
    21: { c: [30], cpp: [32], python: [20] },
    23: { c: [32], cpp: [34], python: [22] },
    24: { c: [33], cpp: [35], python: [23] },
    25: { c: [34], cpp: [36], python: [24] },
    26: { c: [36, 37, 38], cpp: [38, 39, 40], python: [26, 27, 28] },
    27: { c: [39], cpp: [41], python: [29] },
    28: { c: [40], cpp: [42], python: [29] },
    29: { c: [41], cpp: [43], python: [30] },
    31: { c: [43], cpp: [45], python: [32] },
    32: { c: [44], cpp: [46], python: [33] },
    33: { c: [45], cpp: [47], python: [33] },
    35: { c: [47, 48, 49], cpp: [49, 50, 51], python: [35] },
    36: { c: [50], cpp: [52], python: [35] },
    37: { c: [51], cpp: [53], python: [36] },
    38: { c: [52], cpp: [54], python: [36] },
    39: { c: [53], cpp: [55], python: [37] },
    40: { c: [54], cpp: [56], python: [37] },
  },
  hasAdvancedAuxiliaryVisuals: false,
}
