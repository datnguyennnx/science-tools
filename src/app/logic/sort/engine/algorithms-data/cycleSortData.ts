'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { cycleSortGenerator } from '../algorithms'

const rawPlaintextPseudoCode = [
  'procedure cycleSort(list, direction)',
  '  n = length of list',
  '  for cycleStart = 0 to n - 2',
  '    itemInHand = list[cycleStart]',
  '    pos = cycleStart',
  '    for i = cycleStart + 1 to n - 1',
  '      if (direction == ASC and list[i] < itemInHand) or (direction == DESC and list[i] > itemInHand) then',
  '        pos = pos + 1',
  '      end if',
  '    end for',
  '',
  '    if pos == cycleStart then',
  '      continue',
  '    end if',
  '',
  '    while itemInHand == list[pos]',
  '      pos = pos + 1',
  '    end while',
  '',
  '    if pos != cycleStart then',
  '      swap itemInHand with list[pos]',
  '    end if',
  '',
  '    while pos != cycleStart',
  '      pos = cycleStart',
  '      for i = cycleStart + 1 to n - 1',
  '        if (direction == ASC and list[i] < itemInHand) or (direction == DESC and list[i] > itemInHand) then',
  '          pos = pos + 1',
  '        end if',
  '      end for',
  '',
  '      while itemInHand == list[pos]',
  '        pos = pos + 1',
  '      end while',
  '',
  '      if itemInHand != list[pos] then',
  '        swap itemInHand with list[pos]',
  '      end if',
  '    end while',
  '  end for',
  'end procedure',
]

export const cycleSortData: SortAlgorithm = {
  id: 'cycleSort',
  name: 'Cycle Sort',
  description:
    'Cycle Sort is an in-place sorting algorithm that is optimal in terms of the number of writes to the original array. It is based on the idea of permutations and cycles. For each element, it finds its correct position in the sorted array and rotates the elements that are in the way to complete a cycle. This minimizes writes because each element is written at most once to its final sorted position. While it has a worst-case time complexity of O(n^2), its focus on minimizing writes makes it suitable for scenarios where writes are significantly more expensive than reads.',
  generator: cycleSortGenerator,
  complexity: { time: { best: 'O(n^2)', average: 'O(n^2)', worst: 'O(n^2)' }, space: 'O(1)' },
  origin: { name: 'J.P. Black & P.J.P. Taylor', year: 1990 },
  img: '',
  pseudoCode: rawPlaintextPseudoCode,
  languageExamples: {
    c: [
      '#include <stdbool.h>',
      '#include <stdio.h>',
      '',
      '// Note: Cycle sort typically swaps item_in_hand with arr[pos], ',
      "// so a direct swapElementsCycle helper for two array elements isn\'t used the same way.",
      '',
      'void cycleSort(int arr[], int n, bool ascending) {',
      '    if (n <= 1) return;',
      '',
      '    for (int cycle_start = 0; cycle_start <= n - 2; cycle_start++) {',
      '        int item_in_hand = arr[cycle_start];',
      '        int pos = cycle_start;',
      '',
      '        // Find position where item_in_hand should be put',
      '        for (int i = cycle_start + 1; i < n; i++) {',
      '',
      '            if (ascending) {',
      '                if (arr[i] < item_in_hand) pos++;',
      '            } else {',
      '                if (arr[i] > item_in_hand) pos++;',
      '            }',
      '        }',
      '',
      '        // If item_in_hand is already in correct position, go to next cycle',
      '        if (pos == cycle_start) continue;',
      '',
      '        // Skip duplicates if any, to find the correct first position for item_in_hand',
      '        while (pos < n && item_in_hand == arr[pos]) { // Added pos < n check',
      '',
      '            pos++;',
      '        }',
      '        if (pos >= n) continue; // All remaining are duplicates or item_in_hand is largest',
      '',
      '        // Put item_in_hand to its right position',
      '        if (pos != cycle_start) { ',
      '',
      '            int temp_val_at_pos = arr[pos];',
      '            arr[pos] = item_in_hand;',
      '            item_in_hand = temp_val_at_pos;',
      '        }',
      '',
      '        // Rotate rest of the cycle',
      '        while (pos != cycle_start) {',
      '',
      '            pos = cycle_start;',
      '            // Find position where item_in_hand should be put',
      '            for (int i = cycle_start + 1; i < n; i++) {',
      '                if (ascending) {',
      '                    if (arr[i] < item_in_hand) pos++;',
      '                } else {',
      '                    if (arr[i] > item_in_hand) pos++;',
      '                }',
      '            }',
      '',
      '            // Skip duplicates',
      '            while (pos < n && item_in_hand == arr[pos]) { // Added pos < n check',
      '',
      '                pos++;',
      '            }',
      '            if (pos >= n) break; // Cycle broken if pos goes out of bounds',
      '',
      '            // Put item_in_hand to its right position',
      '            if (item_in_hand != arr[pos]) { // Only swap if different',
      '',
      '                 int temp_val_at_pos = arr[pos];',
      '                 arr[pos] = item_in_hand;',
      '                 item_in_hand = temp_val_at_pos;',
      '            } else if (pos == cycle_start && item_in_hand == arr[pos]) {',
      "                 // This condition means item is back at start, and it\'s the same item.",
      '                 // Cycle is complete for this item_in_hand.',
      '                 break; // Break from inner while loop',
      '            }',
      '        }',
      '    }',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <utility>',
      '#include <iostream>',
      '',
      'template <typename T>',
      'void cycleSort(std::vector<T>& arr, bool ascending) {',
      '    int n = arr.size();',
      '    if (n <= 1) return;',
      '',
      '    for (int cycle_start = 0; cycle_start <= n - 2; ++cycle_start) {',
      '        T item_in_hand = arr[cycle_start];',
      '        int pos = cycle_start;',
      '',
      '        for (int i = cycle_start + 1; i < n; ++i) {',
      '',
      '            if (ascending) {',
      '                if (arr[i] < item_in_hand) pos++;',
      '            } else {',
      '                if (arr[i] > item_in_hand) pos++;',
      '            }',
      '        }',
      '',
      '        if (pos == cycle_start) continue;',
      '',
      '        while (pos < n && item_in_hand == arr[pos]) {',
      '',
      '            pos++;',
      '        }',
      '',
      '        if (pos < n && pos != cycle_start) { ',
      '            T temp_val_at_pos = arr[pos];',
      '            arr[pos] = item_in_hand;',
      '            item_in_hand = temp_val_at_pos;',
      '        } else if (pos >=n) { continue; }',
      '',
      '        while (pos != cycle_start) {',
      '',
      '            pos = cycle_start;',
      '            for (int i = cycle_start + 1; i < n; ++i) {',
      '                if (ascending) {',
      '                    if (arr[i] < item_in_hand) pos++;',
      '                } else {',
      '                    if (arr[i] > item_in_hand) pos++;',
      '                }',
      '            }',
      '            while (pos < n && item_in_hand == arr[pos]) {',
      '',
      '                pos++;',
      '            }',
      '            if (pos < n && pos != cycle_start && item_in_hand != arr[pos]) { ',
      '                T temp_val_at_pos = arr[pos];',
      '                arr[pos] = item_in_hand;',
      '                item_in_hand = temp_val_at_pos;',
      '            } else if (item_in_hand == arr[pos] || pos >=n || pos == cycle_start ) {',
      '                 break;',
      '            }',
      '        }',
      '    }',
      '}',
    ],
    python: [
      'def cycleSort(arr, ascending=True):',
      '    n = len(arr)',
      '    if n <= 1:',
      '        return arr',
      '',
      '    for cycle_start in range(n - 1):',
      '        item_in_hand = arr[cycle_start]',
      '        pos = cycle_start',
      '',
      '        for i in range(cycle_start + 1, n):',
      '',
      '            if ascending:',
      '                if arr[i] < item_in_hand:',
      '                    pos += 1',
      '            else:',
      '                if arr[i] > item_in_hand:',
      '                    pos += 1',
      '',
      '        if pos == cycle_start:',
      '',
      '            continue',
      '',
      '        while pos < n and item_in_hand == arr[pos]:',
      '            pos += 1',
      '',
      '        if pos < n and pos != cycle_start:',
      '',
      '             arr[pos], item_in_hand = item_in_hand, arr[pos]',
      '        elif pos >= n :',
      '             continue',
      '',
      '        while pos != cycle_start:',
      '',
      '            pos = cycle_start',
      '            for i in range(cycle_start + 1, n):',
      '                if ascending:',
      '                    if arr[i] < item_in_hand:',
      '                        pos += 1',
      '                else:',
      '                    if arr[i] > item_in_hand:',
      '                        pos += 1',
      '',
      '            while pos < n and item_in_hand == arr[pos]:',
      '',
      '                pos += 1',
      '',
      '            if pos < n and item_in_hand != arr[pos] and pos != cycle_start:',
      '                arr[pos], item_in_hand = item_in_hand, arr[pos]',
      '            elif item_in_hand == arr[pos] or pos >=n or pos == cycle_start:',
      '                break',
      '',
      '    return arr',
    ],
  },
  pseudoCodeMapping: {
    0: { c: [10], cpp: [6], python: [1] },
    1: { c: [10], cpp: [7], python: [2] },
    2: { c: [12], cpp: [10], python: [6] },
    3: { c: [13], cpp: [11], python: [7] },
    4: { c: [14], cpp: [12], python: [8] },
    5: { c: [16], cpp: [14], python: [10] },
    6: { c: [17, 20], cpp: [15, 18], python: [11, 14] },
    7: { c: [18, 21], cpp: [16, 19], python: [13, 16] },
    8: { c: [19, 22], cpp: [17, 20], python: [13, 16] },
    9: { c: [23], cpp: [21], python: [16] },
    11: { c: [25], cpp: [23], python: [18] },
    12: { c: [25], cpp: [23], python: [19] },
    13: { c: [25], cpp: [23], python: [19] },
    15: { c: [27], cpp: [25], python: [21] },
    16: { c: [28], cpp: [26], python: [22] },
    17: { c: [29], cpp: [27], python: [22] },
    19: { c: [31], cpp: [29], python: [24] },
    20: { c: [32, 34], cpp: [30, 32], python: [25] },
    21: { c: [35], cpp: [33], python: [25] },
    23: { c: [37], cpp: [35], python: [28] },
    24: { c: [38], cpp: [36], python: [29] },
    25: { c: [39], cpp: [37], python: [30] },
    26: { c: [40, 43], cpp: [38, 41], python: [31, 34] },
    27: { c: [41, 44], cpp: [39, 42], python: [33, 36] },
    28: { c: [42, 45], cpp: [40, 43], python: [33, 36] },
    29: { c: [46], cpp: [44], python: [36] },
    31: { c: [47], cpp: [45], python: [38] },
    32: { c: [48], cpp: [46], python: [39] },
    33: { c: [49], cpp: [47], python: [39] },
    35: { c: [50], cpp: [48], python: [41] },
    36: { c: [51, 53], cpp: [49, 51], python: [42] },
    37: { c: [54], cpp: [52], python: [42] }, // Simplified mapping after comment removal
    38: { c: [55], cpp: [53], python: [43] },
    39: { c: [56], cpp: [54], python: [43] },
    40: { c: [57], cpp: [55], python: [44] },
  },
  performancePaths: {
    best: [0, 1, 2, 3, 4, 5, 9, 11, 12, 13, 39, 40],
    worst: [
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 13, 15, 16, 17, 19, 20, 21, 23, 24, 25, 26, 27, 28, 29, 31,
      32, 33, 35, 36, 37, 38, 23, 38, 39, 40,
    ],
    average: [
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 13, 15, 16, 17, 19, 20, 21, 23, 24, 25, 26, 27, 28, 29, 31,
      32, 33, 35, 36, 37, 38, 39, 40,
    ],
  },
  hasAdvancedAuxiliaryVisuals: false,
}
