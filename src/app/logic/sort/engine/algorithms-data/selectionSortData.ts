'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { selectionSortGenerator } from '../algorithms'

const rawPlaintextPseudoCode = [
  'procedure selectionSort(list, direction)',
  '  n = length of list',
  '  for i = 0 to n - 2',
  '    extremeIndex = i',
  '    for j = i + 1 to n - 1',
  '      if (direction == ASC and list[j] < list[extremeIndex]) or (direction == DESC and list[j] > list[extremeIndex]) then',
  '        extremeIndex = j',
  '      end if',
  '    end for',
  '    if extremeIndex != i then',
  '      swap(list[i], list[extremeIndex])',
  '    end if',
  '  end for',
  'end procedure',
]

export const selectionSortData: SortAlgorithm = {
  id: 'selectionSort',
  name: 'Selection Sort',
  description:
    'Selection Sort divides the input list into two parts: a sorted sublist built from left to right and the remaining unsorted sublist. The algorithm repeatedly finds the minimum element from the unsorted sublist and swaps it with the leftmost element of the unsorted sublist, effectively expanding the sorted portion. While straightforward, its O(n^2) complexity in all cases makes it less suitable for large datasets compared to more advanced algorithms.',
  generator: selectionSortGenerator,
  complexity: { time: { best: 'O(n^2)', average: 'O(n^2)', worst: 'O(n^2)' }, space: 'O(1)' },
  origin: { name: 'Fundamental/Early' },
  img: '',
  pseudoCode: rawPlaintextPseudoCode,
  languageExamples: {
    c: [
      '#include <stdbool.h>',
      '',
      'void swap(int* xp, int* yp) {',
      '    int temp = *xp;',
      '    *xp = *yp;',
      '    *yp = temp;',
      '}',
      '',
      'void selectionSort(int arr[], int n, bool ascending) {',
      '    int i, j, extreme_idx;',
      '    if (n <= 1) return;',
      '    for (i = 0; i < n - 1; i++) {',
      '        extreme_idx = i;',
      '        for (j = i + 1; j < n; j++) {',
      '            bool isMoreExtreme;',
      '            if (ascending) {',
      '                isMoreExtreme = (arr[j] < arr[extreme_idx]);',
      '            } else {',
      '                isMoreExtreme = (arr[j] > arr[extreme_idx]);',
      '            }',
      '            if (isMoreExtreme) {',
      '                extreme_idx = j;',
      '            }',
      '        }',
      '        if (extreme_idx != i) {',
      '            swap(&arr[extreme_idx], &arr[i]);',
      '        }',
      '    }',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <utility> // For std::swap',
      '',
      'template <typename T>',
      'void selectionSort(std::vector<T>& arr, bool ascending) {',
      '    int n = arr.size();',
      '    if (n <= 1) return;',
      '    for (int i = 0; i < n - 1; i++) {',
      '        int extreme_idx = i;',
      '        for (int j = i + 1; j < n; j++) {',
      '            bool isMoreExtreme;',
      '            if (ascending) {',
      '                isMoreExtreme = (arr[j] < arr[extreme_idx]);',
      '            } else {',
      '                isMoreExtreme = (arr[j] > arr[extreme_idx]);',
      '            }',
      '            if (isMoreExtreme) {',
      '                extreme_idx = j;',
      '            }',
      '        }',
      '        if (extreme_idx != i) {',
      '            std::swap(arr[extreme_idx], arr[i]);',
      '        }',
      '    }',
      '}',
    ],
    python: [
      'def selection_sort(arr, ascending=True):',
      '    n = len(arr)',
      '    if n <= 1:',
      '        return arr',
      '    for i in range(n - 1):',
      '        extreme_idx = i',
      '        for j in range(i + 1, n):',
      '            is_more_extreme = False',
      '            if ascending:',
      '                if arr[j] < arr[extreme_idx]:',
      '                    is_more_extreme = True',
      '            else:  # descending',
      '                if arr[j] > arr[extreme_idx]:',
      '                    is_more_extreme = True',
      '            if is_more_extreme:',
      '                extreme_idx = j',
      '        if extreme_idx != i:',
      '            arr[i], arr[extreme_idx] = arr[extreme_idx], arr[i]',
      '    return arr',
    ],
  },
  pseudoCodeMapping: {
    0: { c: [9], cpp: [5], python: [1] },
    1: { c: [11], cpp: [7], python: [2] },
    2: { c: [12], cpp: [9], python: [5] },
    3: { c: [13], cpp: [10], python: [6] },
    4: { c: [14], cpp: [11], python: [7] },
    5: { c: [15, 16, 17, 18, 19], cpp: [12, 13, 14, 15, 16], python: [8, 9, 10, 11, 12, 13, 14] },
    6: { c: [21], cpp: [18], python: [16] },
    7: { c: [22], cpp: [19], python: [14] },
    8: { c: [23], cpp: [20], python: [7] },
    9: { c: [24], cpp: [21], python: [18] },
    10: { c: [25], cpp: [22], python: [19] },
    11: { c: [26], cpp: [23], python: [18] },
    12: { c: [27], cpp: [24], python: [5] },
    13: { c: [28], cpp: [25], python: [20] },
  },
  performancePaths: {
    best: [0, 1, 2, 3, 4, 5, 7, 8, 9, 11, 12, 13],
    worst: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
    average: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
  },
  hasAdvancedAuxiliaryVisuals: false,
}
