'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { selectionSortGenerator } from '../algorithms'

export const selectionSortData: SortAlgorithm = {
  id: 'selectionSort',
  name: 'Selection Sort',
  description:
    'Selection Sort divides the input list into two parts: a sorted sublist built from left to right and the remaining unsorted sublist. The algorithm repeatedly finds the minimum element from the unsorted sublist and swaps it with the leftmost element of the unsorted sublist, effectively expanding the sorted portion. While straightforward, its O(n^2) complexity in all cases makes it less suitable for large datasets compared to more advanced algorithms.',
  generator: selectionSortGenerator,
  complexity: { time: { best: 'O(n^2)', average: 'O(n^2)', worst: 'O(n^2)' }, space: 'O(1)' },
  origin: { name: 'Fundamental/Early' },
  img: '',
  pseudoCodes: {
    plaintext: [
      'procedure selectionSort(list)',
      '  n = length of list',
      '  for i = 0 to n - 2',
      '    minIndex = i // Stores index of min (for asc) or max (for desc)',
      '    for j = i + 1 to n - 1',
      '      // For ascending sort: list[j] < list[minIndex]',
      '      // For descending sort: list[j] > list[minIndex]',
      '      if list[j] < list[minIndex] then // Defaulting to ascending (find min)',
      '        minIndex = j',
      '      end if',
      '    end for',
      '    if minIndex != i then',
      '      swap(list[i], list[minIndex])',
      '    end if',
      '  end for',
      'end procedure',
    ],
    c: [
      'void swap(int* a, int* b) {',
      '  int temp = *a;',
      '  *a = *b;',
      '  *b = temp;',
      '}',
      '',
      'void selectionSort(int arr[], int n) {',
      '  int i, j, minIndex;',
      '  for (i = 0; i < n - 1; i++) {',
      '    minIndex = i; // Stores index of min (for asc) or max (for desc)',
      '    for (j = i + 1; j < n; j++) {',
      '      // For ascending sort: arr[j] < arr[minIndex]',
      '      // For descending sort: arr[j] > arr[minIndex]',
      '      if (arr[j] < arr[minIndex]) { // Defaulting to ascending (find min)',
      '        minIndex = j;',
      '      }',
      '    }',
      '    if (minIndex != i) {',
      '      swap(&arr[i], &arr[minIndex]);',
      '    }',
      '  }',
      '}',
    ],
    cpp: [
      '#include <utility> // For std::swap',
      '',
      'void selectionSort(int arr[], int n) {',
      '  for (int i = 0; i < n - 1; i++) {',
      '    int minIndex = i; // Stores index of min (for asc) or max (for desc)',
      '    for (int j = i + 1; j < n; j++) {',
      '      // For ascending sort: arr[j] < arr[minIndex]',
      '      // For descending sort: arr[j] > arr[minIndex]',
      '      if (arr[j] < arr[minIndex]) { // Defaulting to ascending (find min)',
      '        minIndex = j;',
      '      }',
      '    }',
      '    if (minIndex != i) {',
      '      std::swap(arr[i], arr[minIndex]);',
      '    }',
      '  }',
      '}',
    ],
    python: [
      'def selectionSort(arr):',
      '  n = len(arr)',
      '  for i in range(n - 1):',
      '    minIndex = i # Stores index of min (for asc) or max (for desc)',
      '    for j in range(i + 1, n):',
      '      # For ascending sort: arr[j] < arr[minIndex]',
      '      # For descending sort: arr[j] > arr[minIndex]',
      '      if arr[j] < arr[minIndex]: # Defaulting to ascending (find min)',
      '        minIndex = j',
      '    if minIndex != i:',
      '      arr[i], arr[minIndex] = arr[minIndex], arr[i]',
    ],
  },
  hasAdvancedAuxiliaryVisuals: false,
}
