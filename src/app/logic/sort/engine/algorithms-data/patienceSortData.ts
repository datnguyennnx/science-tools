'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { patienceSortGenerator } from '../algorithms'

export const patienceSortData: SortAlgorithm = {
  id: 'patienceSort',
  name: 'Patience Sort',
  description:
    'Patience Sorting, named by C. L. Mallows (attributed to A.S.C. Ross), simulates playing a game of patience. Elements are dealt one by one onto a set of piles: an element is placed on the leftmost pile whose top card is greater than or equal to its value (for ascending sort), or a new pile is started if no such pile exists. This pile creation phase also inherently finds the length of the longest increasing subsequence of the input. The sorted list is then formed by repeatedly picking the smallest top card from all non-empty piles (often using a min-heap for efficiency in the merge phase) until all cards are collected. Its history is tied to computing the LIS (Hammersley), and it was later recognized as a full sorting algorithm (Ross, Floyd). While elegant, its typical implementation uses O(n) auxiliary space for the piles.',
  generator: patienceSortGenerator,
  complexity: {
    time: { best: 'O(n)', average: 'O(n log n)', worst: 'O(n log n)' },
    space: 'O(n)',
  },
  origin: { name: 'A.S.C. Ross, C.L. Mallows, J.M. Hammersley', year: 'c. 1960s-1970s' },
  img: '',
  pseudoCodes: {
    plaintext: [
      'procedure patienceSort(list)',
      '  piles = [] // List of piles; each pile is a list/stack of elements',
      '',
      '  // Phase 1: Deal elements into piles',
      '  for each element in list',
      '    targetPileIndex = -1',
      '    // Find the leftmost pile whose top card is >= element (for ascending sort)',
      '    // For descending sort: find leftmost pile whose top card is <= element',
      '    for j = 0 to length of piles - 1',
      '      if piles[j].top_card >= element then // Defaulting to ascending logic',
      '        targetPileIndex = j',
      '        break // Found the leftmost suitable pile',
      '      end if',
      '    end for',
      '    if targetPileIndex != -1 then',
      '      add element to top of piles[targetPileIndex] // Pile top cards are kept >= new element',
      '    else',
      '      create a new_pile with element as its only card',
      '      add new_pile to piles (to the right of existing piles)',
      '    end if',
      '  end for',
      '',
      '  // Phase 2: Merge piles (repeatedly extract minimum top card)',
      '  // For descending sort, this phase would repeatedly extract the maximum top card.',
      '  sortedList = []',
      '  while length of sortedList < length of list',
      '    minTopPileIndex = -1',
      '    minTopCardValue = "infinity" // Represents a very large number (or -infinity for max extraction)',
      '    for j = 0 to length of piles - 1',
      '      if piles[j] is not empty then',
      '        // For ascending sort: piles[j].top_card < minTopCardValue',
      '        // For descending sort: piles[j].top_card > maxTopCardValue (if using max extraction)',
      '        if piles[j].top_card < minTopCardValue then // Defaulting to ascending (find min)',
      '          minTopCardValue = piles[j].top_card',
      '          minTopPileIndex = j',
      '        end if',
      '      end if',
      '    end for',
      '    if minTopPileIndex == -1 then break // Should not happen if list was not empty',
      '    add minTopCardValue to sortedList',
      '    remove top_card from piles[minTopPileIndex]',
      '  end while',
      '  return sortedList',
      'end procedure',
    ],
    c: [
      '// Requires a dynamic way to handle piles, e.g., array of linked lists or vector of vectors.',
      '// This C code is conceptual and assumes helper functions for pile management.',
      '// Adapting for descending sort would involve changing the comparison logic in pile placement',
      '// (placing on piles where top <= element) and in merge (extracting max top card).',
      'void patienceSort(int arr[], int n) {',
      '  if (n == 0) return;',
      '  // Conceptual: std::vector<std::vector<int>> piles; in C++ would be analogous.',
      '',
      '  // Phase 1: Deal cards into piles (Abstracted)',
      '  // For each element `x` in `arr`:',
      '  //   Find `j_target` = leftmost pile index `j` such that top_card(piles[j]) >= x (for asc) or <= x (for desc).',
      '  //   If `j_target` found, add `x` to `piles[j_target]`.',
      '  //   Else, create new pile with `x`.',
      '',
      '  // Phase 2: Merge piles (Abstracted)',
      '  // int sorted_idx = 0;',
      '  // While sorted_idx < n:',
      '  //   Find pile `p_extreme` among non-empty piles with the smallest (for asc) or largest (for desc) top_card.',
      '  //   `arr[sorted_idx++] = top_card(p_extreme);`',
      '  //   Remove top_card from `p_extreme`.',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <algorithm> // For std::min_element with custom comparator if needed',
      '#include <limits>    // For std::numeric_limits',
      '',
      'void patienceSort(std::vector<int>& arr) {',
      '  if (arr.empty()) return;',
      '  int n = arr.size();',
      '  std::vector<std::vector<int>> piles; // Each inner vector is a pile, piles[j].back() is the top card',
      '',
      '  // Phase 1: Deal cards into piles',
      '  for (int x : arr) {',
      '    int targetPileIdx = -1;',
      '    for (size_t j = 0; j < piles.size(); ++j) {',
      '      // For ascending: piles[j].back() >= x',
      '      // For descending: piles[j].back() <= x (and pile is non-empty)',
      '      if (!piles[j].empty() && piles[j].back() >= x) { // Defaulting to ascending logic',
      '        targetPileIdx = j;',
      '        break; // Found the leftmost suitable pile',
      '      }',
      '    }',
      '    if (targetPileIdx != -1) {',
      '      piles[targetPileIdx].push_back(x); // Add to the top of this pile',
      '    } else {',
      '      piles.push_back({x}); // Start a new pile to the right',
      '    }',
      '  }',
      '',
      '  // Phase 2: Merge piles',
      '  // For descending sort, find and extract max top card, e.g., initialize minTopCard to numeric_limits<int>::min() and compare with >.',
      '  arr.assign(n, 0); // Resize and initialize for sorted output',
      '  for (int i = 0; i < n; ++i) {',
      '    int minTopPileIndex = -1;',
      '    // Initialize with a value larger than any possible card, or handle first element carefully',
      '    int minTopCard = std::numeric_limits<int>::max(); ',
      '    for (size_t j = 0; j < piles.size(); ++j) {',
      '      if (!piles[j].empty()) {',
      '        // For ascending sort: piles[j].back() < minTopCard',
      '        // For descending sort: piles[j].back() > maxTopCard (if using max extraction logic)',
      '        if (piles[j].back() < minTopCard) { // Defaulting to ascending (find min)',
      '          minTopCard = piles[j].back();',
      '          minTopPileIndex = j;',
      '        }',
      '      }',
      '    }',
      '    if (minTopPileIndex != -1) { // Ensure a pile was found',
      '      arr[i] = minTopCard;',
      '      piles[minTopPileIndex].pop_back();',
      '    } else {',
      '      // This case should ideally not be reached if n > 0 and piles were formed correctly',
      '      break;',
      '    }',
      '  }',
      '}',
    ],
    python: [
      'import heapq',
      '',
      'def patience_sort(arr):',
      '    if not arr:',
      '        return []',
      '    piles = [] # List of piles; each pile is a list, pile[-1] is the top card',
      '',
      '    # Phase 1: Deal cards into piles',
      '    for x in arr:',
      '        target_pile_idx = -1',
      '        for i, pile in enumerate(piles):',
      '            # Standard rule: place x on leftmost pile whose top (pile[-1]) is >= x (for ascending)',
      '            # For descending: place x on leftmost pile whose top (pile[-1]) is <= x',
      '            if pile[-1] >= x: # Defaulting to ascending logic',
      '                target_pile_idx = i',
      '                break # Found the leftmost pile',
      '        ',
      '        if target_pile_idx != -1:',
      '            piles[target_pile_idx].append(x)',
      '        else:',
      '            piles.append([x]) # Start a new pile',
      '',
      '    # Phase 2: Merge piles using a min-heap',
      '    # For descending sort, a max-heap would be used (e.g., by storing negated values in a min-heap).',
      '    # The heap stores (card_value, pile_index_from_piles_list)',
      '    # pile[-1] is the top card of a pile, as new cards are appended.',
      '    result = []',
      '    min_heap = []',
      '    for i, pile in enumerate(piles):',
      '        if pile: # If pile is not empty',
      '            heapq.heappush(min_heap, (pile[-1], i)) # (value_on_top, pile_list_index)',
      '',
      '    while min_heap:',
      '        val, pile_idx = heapq.heappop(min_heap)',
      '        result.append(val)',
      '        piles[pile_idx].pop() # Remove the card from its original pile (from the end/top)',
      '        if piles[pile_idx]: # If pile still has cards',
      '            heapq.heappush(min_heap, (piles[pile_idx][-1], pile_idx)) # Add next card from this pile',
      '    return result',
    ],
  },
}
