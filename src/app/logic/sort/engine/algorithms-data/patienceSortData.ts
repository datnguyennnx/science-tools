import type { SortAlgorithm } from '../algorithmRegistry'

const rawPlaintextPseudoCode = [
  'procedure patienceSort(list)',
  '  piles = []',
  '',
  '  for each element in list',
  '    targetPileIndex = -1',
  '    for j = 0 to length of piles - 1',
  '      if piles[j].top_card >= element then',
  '        targetPileIndex = j',
  '        break',
  '      end if',
  '    end for',
  '    if targetPileIndex != -1 then',
  '      add element to top of piles[targetPileIndex]',
  '    else',
  '      create a new_pile with element as its only card',
  '      add new_pile to piles',
  '    end if',
  '  end for',
  '',
  '  sortedList = []',
  '  while length of sortedList < length of list',
  '    minTopPileIndex = -1',
  '    minTopCardValue = "infinity"',
  '    for j = 0 to length of piles - 1',
  '      if piles[j] is not empty then',
  '        if piles[j].top_card < minTopCardValue then',
  '          minTopCardValue = piles[j].top_card',
  '          minTopPileIndex = j',
  '        end if',
  '      end if',
  '    end for',
  '    if minTopPileIndex == -1 then break',
  '    add minTopCardValue to sortedList',
  '    remove top_card from piles[minTopPileIndex]',
  '  end while',
  '  return sortedList',
  'end procedure',
]

export const patienceSortData: SortAlgorithm = {
  id: 'patienceSort',
  name: 'Patience Sort',
  description:
    'Patience Sorting, named by C. L. Mallows (attributed to A.S.C. Ross), simulates playing a game of patience. Elements are dealt one by one onto a set of piles: an element is placed on the leftmost pile whose top card is greater than or equal to its value (for ascending sort), or a new pile is started if no such pile exists. This pile creation phase also inherently finds the length of the longest increasing subsequence of the input. The sorted list is then formed by repeatedly picking the smallest top card from all non-empty piles (often using a min-heap for efficiency in the merge phase) until all cards are collected. Its history is tied to computing the LIS (Hammersley), and it was later recognized as a full sorting algorithm (Ross, Floyd). While elegant, its typical implementation uses O(n) auxiliary space for the piles.',
  complexity: {
    time: { best: 'O(n)', average: 'O(n log n)', worst: 'O(n log n)' },
    space: 'O(n)',
  },
  origin: { name: 'A.S.C. Ross, C.L. Mallows, J.M. Hammersley', year: 'c. 1960s-1970s' },
  img: '',
  pseudoCode: rawPlaintextPseudoCode,
  languageExamples: {
    c: [
      '#include <stdlib.h>',
      '#include <stdbool.h>',
      '#include <limits.h> // For INT_MAX',
      '',
      'typedef struct {',
      '    int* items;',
      '    int top;',
      '    int capacity;',
      '} Pile;',
      '',
      'Pile createPile(int capacity) {',
      '    Pile p;',
      '    p.items = (int*)malloc(capacity * sizeof(int));',
      '    if (p.items == NULL) { p.capacity = 0; p.top = -1; return p; }',
      '    p.top = -1;',
      '    p.capacity = capacity;',
      '    return p;',
      '}',
      '',
      'void pushToPile(Pile* p, int item) {',
      '    if (p->items != NULL && p->top < p->capacity - 1) {',
      '        p->items[++(p->top)] = item;',
      '    }',
      '}',
      '',
      'int popFromPile(Pile* p) {',
      '    if (p->items != NULL && p->top >= 0) {',
      '        return p->items[(p->top)--];',
      '    }',
      '    return -1; // Error or empty',
      '}',
      '',
      'int peekPile(Pile* p) {',
      '    if (p->items != NULL && p->top >= 0) {',
      '        return p->items[p->top];',
      '    }',
      '    return INT_MAX; // Sentinel for empty pile for ascending sort',
      '}',
      '',
      'void patienceSort(int arr[], int n, bool ascending) {',
      '    if (n <= 1) return;',
      '',
      '    Pile* piles = (Pile*)malloc(n * sizeof(Pile));',
      '    if (piles == NULL) return;',
      '    int numPiles = 0;',
      '',
      '    for (int i = 0; i < n; i++) {',
      '        int element = arr[i];',
      '        int targetPileIndex = -1;',
      '        int smallestTopCandidate = INT_MAX;',
      '',
      '        for (int j = 0; j < numPiles; j++) {',
      '            if (piles[j].top >=0 && peekPile(&piles[j]) >= element) {',
      '                if (peekPile(&piles[j]) < smallestTopCandidate) {',
      '                    smallestTopCandidate = peekPile(&piles[j]);',
      '                    targetPileIndex = j;',
      '                }',
      '            }',
      '        }',
      '',
      '        if (targetPileIndex != -1) {',
      '            pushToPile(&piles[targetPileIndex], element);',
      '        } else {',
      '            piles[numPiles] = createPile(n);',
      '            if (piles[numPiles].items == NULL) { /* Free prev piles & return */ ',
      '                for(int k=0; k<numPiles; ++k) if(piles[k].items) free(piles[k].items);',
      '                free(piles);',
      '                return; ',
      '            }',
      '            pushToPile(&piles[numPiles], element);',
      '            numPiles++;',
      '        }',
      '    }',
      '',
      '    for (int i = 0; i < n; i++) {',
      '        int minTopPileIndex = -1;',
      '        int minTopCardValue = INT_MAX;',
      '',
      '        for (int j = 0; j < numPiles; j++) {',
      '            if (piles[j].top >= 0) { // If pile is not empty',
      '                if (peekPile(&piles[j]) < minTopCardValue) {',
      '                    minTopCardValue = peekPile(&piles[j]);',
      '                    minTopPileIndex = j;',
      '                }',
      '            }',
      '        }',
      '        if (minTopPileIndex != -1) {',
      '            arr[i] = popFromPile(&piles[minTopPileIndex]);',
      '        } else {',
      '            break; // Should ideally not happen',
      '        }',
      '    }',
      '',
      '    for (int i = 0; i < numPiles; i++) {',
      '        if (piles[i].items != NULL) free(piles[i].items);',
      '    }',
      '    free(piles);',
      '',
      '    if (!ascending) {',
      '        for(int i = 0; i < n / 2; i++){',
      '            int temp = arr[i];',
      '            arr[i] = arr[n - 1 - i];',
      '            arr[n - 1 - i] = temp;',
      '        }',
      '    }',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <algorithm> // For std::reverse',
      '#include <limits>    // For std::numeric_limits',
      '',
      'template <typename T>',
      'void patienceSort(std::vector<T>& arr, bool ascending) {',
      '    if (arr.empty()) return;',
      '    int n = arr.size();',
      '    if (n <= 1) return;',
      '',
      '    std::vector<std::vector<T>> piles;',
      '',
      '    for (const T& element : arr) {',
      '        int targetPileIndex = -1;',
      '        T smallestTopCandidate = std::numeric_limits<T>::max();',
      '',
      '        for (size_t j = 0; j < piles.size(); ++j) {',
      '            if (!piles[j].empty() && piles[j].back() >= element) {',
      '                if (piles[j].back() < smallestTopCandidate) {',
      '                    smallestTopCandidate = piles[j].back();',
      '                    targetPileIndex = j;',
      '                }',
      '            }',
      '        }',
      '',
      '        if (targetPileIndex != -1) {',
      '            piles[targetPileIndex].push_back(element);',
      '        } else {',
      '            piles.push_back({element});',
      '        }',
      '    }',
      '',
      '    for (int i = 0; i < n; ++i) {',
      '        int minTopPileIndex = -1;',
      '        T minTopCardValue = std::numeric_limits<T>::max();',
      '',
      '        for (size_t j = 0; j < piles.size(); ++j) {',
      '            if (!piles[j].empty()) {',
      '                if (piles[j].back() < minTopCardValue) {',
      '                    minTopCardValue = piles[j].back();',
      '                    minTopPileIndex = j;',
      '                }',
      '            }',
      '        }',
      '',
      '        if (minTopPileIndex != -1) {',
      '            arr[i] = piles[minTopPileIndex].back();',
      '            piles[minTopPileIndex].pop_back();',
      '        } else {',
      '            break;',
      '        }',
      '    }',
      '',
      '    if (!ascending) {',
      '        std::reverse(arr.begin(), arr.end());',
      '    }',
      '}',
    ],
    python: [
      'import math',
      '',
      'def patience_sort(arr, ascending=True):',
      '    n = len(arr)',
      '    if n <= 1:',
      '        return arr',
      '',
      '    piles = []',
      '',
      '    for x in arr:',
      '        placed = False',
      '        target_pile_idx = -1',
      "        smallest_top_candidate = float('inf')",
      '',
      '        for i, pile in enumerate(piles):',
      '            if pile[-1] >= x:',
      '                if pile[-1] < smallest_top_candidate:',
      '                    smallest_top_candidate = pile[-1]',
      '                    target_pile_idx = i',
      '        ',
      '        if target_pile_idx != -1:',
      '            piles[target_pile_idx].append(x)',
      '        else:',
      '            piles.append([x])',
      '',
      '    sorted_arr = []',
      '    for _ in range(n):',
      "        min_val = float('inf')",
      '        min_pile_idx = -1',
      '',
      '        for i, pile in enumerate(piles):',
      '            if pile:',
      '                if pile[-1] < min_val:',
      '                    min_val = pile[-1]',
      '                    min_pile_idx = i',
      '        ',
      '        if min_pile_idx != -1:',
      '            sorted_arr.append(piles[min_pile_idx].pop())',
      '        else:',
      '            break # Should not happen in correct implementation',
      '',
      '    if not ascending:',
      '        sorted_arr.reverse()',
      '    return sorted_arr',
    ],
  },
  pseudoCodeMapping: {
    0: { c: [43], cpp: [7], python: [3] },
    1: { c: [47], cpp: [12], python: [8] },
    3: { c: [50], cpp: [15], python: [11] },
    4: { c: [52, 53], cpp: [16, 17], python: [12, 13] },
    5: { c: [55], cpp: [19], python: [15] },
    6: { c: [56, 57], cpp: [20, 21], python: [16, 17] },
    7: { c: [59], cpp: [23], python: [19] },
    10: { c: [61], cpp: [25], python: [19] }, // end for inner pile search
    11: { c: [63], cpp: [27], python: [21] },
    12: { c: [64], cpp: [28], python: [22] },
    13: { c: [65], cpp: [29], python: [23] },
    14: { c: [66, 67, 68, 69, 70], cpp: [30], python: [24] }, // create new pile block
    15: { c: [71], cpp: [30], python: [24] }, // add new_pile (covered in 14)
    16: { c: [72], cpp: [31], python: [24] }, // end if
    17: { c: [73], cpp: [32], python: [24] }, // end for element loop
    19: { c: [74], cpp: [35], python: [27] }, // sortedList=[] / merge phase init
    20: { c: [74], cpp: [35], python: [33] }, // while length sorted < n / while heap
    21: { c: [75], cpp: [36], python: [33] },
    22: { c: [76], cpp: [37, 38], python: [33] },
    23: { c: [78], cpp: [40], python: [33] }, // Python: heap op covers 23-30 for one element extraction
    24: { c: [79], cpp: [41], python: [33] },
    25: { c: [80, 81], cpp: [42, 43], python: [33] },
    26: { c: [81], cpp: [43], python: [33] },
    27: { c: [82], cpp: [44], python: [33] },
    30: { c: [85], cpp: [47], python: [33] }, // end for (C/CPP internal merge scan)
    31: { c: [86], cpp: [49], python: [33] }, // if minTopPileIndex != -1 / (Python: while min_heap)
    32: { c: [87], cpp: [50], python: [35] },
    33: { c: [87], cpp: [51], python: [38, 39] },
    34: { c: [89], cpp: [53], python: [40] }, // end while merge loop
    35: { c: [103], cpp: [59], python: [49] }, // return (or end of void func for C/CPP if in-place)
    36: { c: [103], cpp: [59], python: [49] }, // end procedure
  },
  performancePaths: {
    best: [0, 1, 3, 4, 5, 10, 13, 14, 15, 16, 17, 19, 20, 21, 22, 23, 30, 31, 32, 33, 34, 35, 36], // Simplified path for mostly sorted
    worst: [
      0, 1, 3, 4, 5, 6, 7, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20, 21, 22, 23, 24, 25, 26, 27, 30,
      31, 32, 33, 34, 35, 36,
    ],
    average: [
      0, 1, 3, 4, 5, 6, 7, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20, 21, 22, 23, 24, 25, 26, 27, 30,
      31, 32, 33, 34, 35, 36,
    ],
  },
}
