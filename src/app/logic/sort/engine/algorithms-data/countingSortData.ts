'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { countingSortGenerator } from '../algorithms'

export const countingSortData: SortAlgorithm = {
  id: 'countingSort',
  name: 'Counting Sort',
  description:
    'Invented by Harold H. Seward in 1954, Counting Sort is a non-comparison sorting algorithm that is effective for sorting a collection of objects according to their keys that are small integers. It works by counting the number of occurrences of each unique key value, then using those counts to determine the positions of each key value in the output sequence. It is often used as a subroutine in other sorting algorithms like Radix Sort and can achieve linear time complexity O(n + k) where k is the range of input values. It is a stable sort, meaning that elements with equal keys appear in the output array in the same order as they do in the input array.',
  generator: countingSortGenerator,
  complexity: {
    time: { best: 'O(n + k)', average: 'O(n + k)', worst: 'O(n + k)' },
    space: 'O(n + k)',
  },
  origin: { name: 'Harold H. Seward', year: 1954 },
  img: 'https://currentobitwebstorage.blob.core.windows.net/067/06822c877d864c47b0b15c7005b30790.jpg',
  pseudoCodes: {
    plaintext: [
      'procedure countingSort(list, minVal, maxVal)',
      '  rangeSize = maxVal - minVal + 1',
      '  count = array of rangeSize zeros',
      '',
      '  // Store count of each element',
      '  for each element in list',
      '    count[element - minVal] = count[element - minVal] + 1',
      '  end for',
      '',
      '  // Store cumulative count',
      '  for i = 1 to rangeSize - 1',
      '    count[i] = count[i] + count[i-1]',
      '  end for',
      '',
      '  // Build the output array',
      '  output = array of same size as list',
      '  for i = length of list - 1 down to 0',
      '    element = list[i]',
      '    output[count[element - minVal] - 1] = element',
      '    count[element - minVal] = count[element - minVal] - 1',
      '  end for',
      '',
      '  // Copy sorted elements back or return output',
      '  for i = 0 to length of list - 1',
      '    list[i] = output[i]',
      '  end for',
      '  // For descending sort, this list (sorted ascending) can be reversed.',
      'end procedure',
    ],
    c: [
      '#include <stdlib.h> // For malloc, calloc, free',
      '#include <string.h> // For memset (optional, calloc handles zeroing)',
      '',
      'void countingSort(int arr[], int n, int minVal, int maxVal) {',
      '  if (n <= 1) return;',
      '  int rangeSize = maxVal - minVal + 1;',
      '  int* count = (int*)calloc(rangeSize, sizeof(int));',
      '  int* output = (int*)malloc(n * sizeof(int));',
      '',
      '  if (count == NULL || output == NULL) { /* TODO: Handle allocation failure */ return; }',
      '',
      '  for (int i = 0; i < n; i++) {',
      '    count[arr[i] - minVal]++;',
      '  }',
      '',
      '  for (int i = 1; i < rangeSize; i++) {',
      '    count[i] += count[i - 1];',
      '  }',
      '',
      '  for (int i = n - 1; i >= 0; i--) {',
      '    output[count[arr[i] - minVal] - 1] = arr[i];',
      '    count[arr[i] - minVal]--;',
      '  }',
      '',
      '  for (int i = 0; i < n; i++) {',
      '    arr[i] = output[i];',
      '  }',
      '',
      '  free(count);',
      '  free(output);',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <algorithm> // Required for std::copy if used',
      '',
      'void countingSort(std::vector<int>& arr, int minVal, int maxVal) {',
      '  if (arr.empty()) return;',
      '  int rangeSize = maxVal - minVal + 1;',
      '  if (rangeSize <= 0) return; // Basic sanity check',
      '',
      '  std::vector<int> count(rangeSize, 0);',
      '  std::vector<int> output(arr.size());',
      '',
      '  for (int x : arr) {',
      '    // Assuming elements are within [minVal, maxVal]',
      '    // Add bound checks if necessary: if (x >= minVal && x <= maxVal)',
      '    count[x - minVal]++;',
      '  }',
      '',
      '  for (size_t i = 1; i < count.size(); i++) {',
      '    count[i] += count[i - 1];',
      '  }',
      '',
      '  for (int i = arr.size() - 1; i >= 0; i--) {',
      '    // Assuming elements are within [minVal, maxVal]',
      '    output[count[arr[i] - minVal] - 1] = arr[i];',
      '    count[arr[i] - minVal]--;',
      '  }',
      '',
      '  // arr = output; // Assign back',
      '  std::copy(output.begin(), output.end(), arr.begin()); // Or copy',
      '}',
    ],
    python: [
      'def counting_sort(arr, min_val, max_val):',
      '  if not arr:',
      '    return [] # Or modify arr in place and return None',
      '  ',
      '  range_size = max_val - min_val + 1',
      '  if range_size <= 0: # Basic sanity check',
      '      # Potentially raise an error or handle as appropriate',
      '      return arr # Return original if range is invalid',
      '',
      '  count = [0] * range_size',
      '  output = [0] * len(arr)',
      '',
      '  for x in arr:',
      '    # Assuming elements are within [min_val, max_val]',
      '    # Add bound checks if necessary: if min_val <= x <= max_val:',
      '    count[x - min_val] += 1',
      '  ',
      '  for i in range(1, range_size):',
      '    count[i] += count[i-1]',
      '  ',
      '  for i in range(len(arr) - 1, -1, -1):',
      '    element = arr[i]',
      '    # Assuming elements are within [min_val, max_val]',
      '    output[count[element - min_val] - 1] = element',
      '    count[element - min_val] -= 1',
      '  ',
      '  # To modify original array in place:',
      '  # for i in range(len(arr)):',
      '  #   arr[i] = output[i]',
      '  # return ',
      '  return output # Return new sorted list',
    ],
  },
}
