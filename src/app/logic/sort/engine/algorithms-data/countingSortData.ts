'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { countingSortGenerator } from '../algorithms'

export const countingSortData: SortAlgorithm = {
  id: 'countingSort',
  name: 'Counting Sort',
  description:
    'Invented by Harold H. Seward in 1954, Counting Sort is a non-comparison sorting algorithm that is effective for sorting a collection of objects according to their keys that are small integers. It works by counting the number of occurrences of each unique key value, then using those counts to determine the positions of each key value in the output sequence. It is often used as a subroutine in other sorting algorithms like Radix Sort and can achieve linear time complexity O(n + k) where k is the range of input values. It is a stable sort, meaning that elements with equal keys appear in the output array in the same order as they do in the input array.',
  generator: countingSortGenerator,
  complexity: {
    time: { best: 'O(n + k)', average: 'O(n + k)', worst: 'O(n + k)' },
    space: 'O(n + k)',
  },
  origin: { name: 'Harold H. Seward', year: 1954 },
  img: 'https://currentobitwebstorage.blob.core.windows.net/067/06822c877d864c47b0b15c7005b30790.jpg',
  pseudoCodes: {
    plaintext: [
      'procedure countingSort(list, minVal, maxVal, direction)',
      '  if length of list <= 1 then',
      '    return list',
      '  end if',
      '',
      '  rangeSize = maxVal - minVal + 1',
      '  count = array of rangeSize zeros',
      '',
      '  for each element in list',
      '    count[element - minVal] = count[element - minVal] + 1',
      '  end for',
      '',
      '  for i = 1 to rangeSize - 1',
      '    count[i] = count[i] + count[i-1]',
      '  end for',
      '',
      '  output = array of same size as list',
      '  for i = length of list - 1 down to 0',
      '    element = list[i]',
      '    outputIndex = count[element - minVal] - 1',
      '    output[outputIndex] = element',
      '    count[element - minVal] = count[element - minVal] - 1',
      '  end for',
      '',
      '  if direction is DESC then',
      '    reverse(output)',
      '  end if',
      '',
      '  for i = 0 to length of list - 1',
      '    list[i] = output[i]',
      '  end for',
      'end procedure',
    ],
    c: [
      '#include <stdlib.h>',
      '#include <string.h>',
      '#include <stdbool.h>',
      '',
      'typedef enum { ASC, DESC } SortDirection;',
      '',
      'void reverse_array(int arr[], int n) {',
      '    int i = 0, j = n - 1, temp;',
      '    while (i < j) {',
      '        temp = arr[i];',
      '        arr[i] = arr[j];',
      '        arr[j] = temp;',
      '        i++; j--;',
      '    }',
      '}',
      '',
      'void countingSort(int arr[], int n, int minVal, int maxVal, SortDirection direction) {',
      '  if (n <= 1) {',
      '    return;',
      '  }',
      '',
      '  int rangeSize = maxVal - minVal + 1;',
      '  if (rangeSize <= 0) {',
      '    return;',
      '  }',
      '',
      '  int* count = (int*)calloc(rangeSize, sizeof(int));',
      '  int* output = (int*)malloc(n * sizeof(int));',
      '',
      '  if (count == NULL || output == NULL) {',
      '    if (count) free(count);',
      '    if (output) free(output);',
      '    return;',
      '  }',
      '',
      '  for (int i = 0; i < n; i++) {',
      '    count[arr[i] - minVal]++;',
      '  }',
      '',
      '  for (int i = 1; i < rangeSize; i++) {',
      '    count[i] += count[i - 1];',
      '  }',
      '',
      '  for (int i = n - 1; i >= 0; i--) {',
      '    output[count[arr[i] - minVal] - 1] = arr[i];',
      '    count[arr[i] - minVal]--;',
      '  }',
      '',
      '  if (direction == DESC) {',
      '    reverse_array(output, n);',
      '  }',
      '',
      '  for (int i = 0; i < n; i++) {',
      '    arr[i] = output[i];',
      '  }',
      '',
      '  free(count);',
      '  free(output);',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <algorithm>',
      '#include <numeric>',
      '',
      'enum class SortDirection { ASC, DESC };',
      '',
      'void countingSort(std::vector<int>& arr, int minVal, int maxVal, SortDirection direction) {',
      '  int n = arr.size();',
      '  if (n <= 1) {',
      '    return;',
      '  }',
      '',
      '  int rangeSize = maxVal - minVal + 1;',
      '  if (rangeSize <= 0) {',
      '    return;',
      '  }',
      '',
      '  std::vector<int> count(rangeSize, 0);',
      '  std::vector<int> output(n);',
      '',
      '  for (int x : arr) {',
      '    count[x - minVal]++;',
      '  }',
      '',
      '  for (size_t i = 1; i < count.size(); i++) {',
      '    count[i] += count[i - 1];',
      '  }',
      '',
      '  for (int i = n - 1; i >= 0; i--) {',
      '    output[count[arr[i] - minVal] - 1] = arr[i];',
      '    count[arr[i] - minVal]--;',
      '  }',
      '',
      '  if (direction == SortDirection::DESC) {',
      '    std::reverse(output.begin(), output.end());',
      '  }',
      '',
      '  std::copy(output.begin(), output.end(), arr.begin());',
      '}',
    ],
    python: [
      'def counting_sort(arr, min_val, max_val, direction="asc"):',
      '  n = len(arr)',
      '  if n <= 1:',
      '    return arr',
      '  ',
      '  range_size = max_val - min_val + 1',
      '  if range_size <= 0:',
      '    return arr ',
      '  ',
      '  count = [0] * range_size',
      '  output = [0] * n',
      '  ',
      '  for x in arr:',
      '    count[x - min_val] += 1',
      '  ',
      '  for i in range(1, range_size):',
      '    count[i] += count[i-1]',
      '  ',
      '  for i in range(n - 1, -1, -1):',
      '    element = arr[i]',
      '    output[count[element - min_val] - 1] = element',
      '    count[element - min_val] -= 1',
      '  ',
      '  if direction == "desc":',
      '    output.reverse()',
      '  ',
      '  for i in range(n):',
      '    arr[i] = output[i]',
      '  return arr',
    ],
  },
  pseudoCodeMapping: {
    0: { c: [16], cpp: [6], python: [0] },
    1: { c: [17], cpp: [8], python: [2] },
    2: { c: [18], cpp: [9], python: [3] },
    3: { c: [19], cpp: [10], python: [3] },
    5: { c: [21], cpp: [12], python: [5] },
    6: { c: [25], cpp: [17], python: [9] },
    8: { c: [31], cpp: [21], python: [12] },
    9: { c: [32], cpp: [22], python: [13] },
    10: { c: [33], cpp: [23], python: [13] },
    12: { c: [35], cpp: [25], python: [15] },
    13: { c: [36], cpp: [26], python: [16] },
    14: { c: [37], cpp: [27], python: [16] },
    16: { c: [26], cpp: [18], python: [10] },
    17: { c: [39], cpp: [29], python: [19] },
    18: { c: [39], cpp: [29], python: [20] },
    19: { c: [40], cpp: [30], python: [21] },
    20: { c: [40], cpp: [30], python: [21] },
    21: { c: [41], cpp: [31], python: [22] },
    22: { c: [42], cpp: [32], python: [22] },
    24: { c: [44], cpp: [34], python: [24] },
    25: { c: [45], cpp: [35], python: [25] },
    26: { c: [46], cpp: [36], python: [25] },
    28: { c: [48], cpp: [38], python: [28] },
    29: { c: [49], cpp: [38], python: [29] },
    30: { c: [50], cpp: [39], python: [30] },
    31: { c: [53], cpp: [39], python: [30] },
  },
  hasAdvancedAuxiliaryVisuals: false,
}
