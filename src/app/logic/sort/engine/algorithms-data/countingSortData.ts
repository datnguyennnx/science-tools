import type { SortAlgorithm } from '../algorithmRegistry'

const rawPlaintextPseudoCode = [
  'procedure countingSort(list, minVal, maxVal, direction)',
  '  if length of list <= 1 then',
  '    return list',
  '  end if',
  '',
  '  rangeSize = maxVal - minVal + 1',
  '  count = array of rangeSize zeros',
  '',
  '  for each element in list',
  '    count[element - minVal] = count[element - minVal] + 1',
  '  end for',
  '',
  '  for i = 1 to rangeSize - 1',
  '    count[i] = count[i] + count[i-1]',
  '  end for',
  '',
  '  output = array of same size as list',
  '  for i = length of list - 1 down to 0',
  '    element = list[i]',
  '    outputIndex = count[element - minVal] - 1',
  '    output[outputIndex] = element',
  '    count[element - minVal] = count[element - minVal] - 1',
  '  end for',
  '',
  '  if direction is DESC then',
  '    reverse(output)',
  '  end if',
  '',
  '  for i = 0 to length of list - 1',
  '    list[i] = output[i]',
  '  end for',
  'end procedure',
]

export const countingSortData: SortAlgorithm = {
  id: 'countingSort',
  name: 'Counting Sort',
  description:
    'Invented by Harold H. Seward in 1954, Counting Sort is a non-comparison sorting algorithm that is effective for sorting a collection of objects according to their keys that are small integers. It works by counting the number of occurrences of each unique key value, then using those counts to determine the positions of each key value in the output sequence. It is often used as a subroutine in other sorting algorithms like Radix Sort and can achieve linear time complexity O(n + k) where k is the range of input values. It is a stable sort, meaning that elements with equal keys appear in the output array in the same order as they do in the input array.',
  complexity: {
    time: { best: 'O(n + k)', average: 'O(n + k)', worst: 'O(n + k)' },
    space: 'O(n + k)',
  },
  origin: { name: 'Harold H. Seward', year: 1954 },
  img: 'https://currentobitwebstorage.blob.core.windows.net/067/06822c877d864c47b0b15c7005b30790.jpg',
  pseudoCode: rawPlaintextPseudoCode,
  languageExamples: {
    c: [
      '#include <stdio.h>',
      '#include <stdlib.h>',
      '#include <string.h>',
      '#include <stdbool.h>',
      '',
      '// Helper to reverse an array (for descending sort)',
      'void reverseArray(int arr[], int n) {',
      '    int start = 0;',
      '    int end = n - 1;',
      '    while (start < end) {',
      '        int temp = arr[start];',
      '        arr[start] = arr[end];',
      '        arr[end] = temp;',
      '        start++;',
      '        end--;',
      '    }',
      '}',
      '',
      'void countingSort(int arr[], int n, bool ascending) {',
      '    if (n <= 1) return;',
      '',
      '    // Calculate minVal and maxVal internally',
      '    int minVal = arr[0];',
      '    int maxVal = arr[0];',
      '    for (int i = 1; i < n; i++) {',
      '        if (arr[i] < minVal) minVal = arr[i];',
      '        if (arr[i] > maxVal) maxVal = arr[i];',
      '    }',
      '',
      '    int range = maxVal - minVal + 1;',
      '    int* count = (int*)calloc(range, sizeof(int));',
      '    int* output = (int*)malloc(n * sizeof(int));',
      '',
      '    if (!count || !output) {',
      '        if (count) free(count);',
      '        if (output) free(output);',
      '        return;',
      '    }',
      '',
      '    for (int i = 0; i < n; i++) {',
      '        count[arr[i] - minVal]++;',
      '    }',
      '',
      '    for (int i = 1; i < range; i++) {',
      '        count[i] += count[i - 1];',
      '    }',
      '',
      '    for (int i = n - 1; i >= 0; i--) {',
      '        output[count[arr[i] - minVal] - 1] = arr[i];',
      '        count[arr[i] - minVal]--;',
      '    }',
      '',
      '    if (!ascending) {',
      '        reverseArray(output, n);',
      '    }',
      '    for (int i = 0; i < n; i++) {',
      '        arr[i] = output[i];',
      '    }',
      '',
      '    free(count);',
      '    free(output);',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <algorithm>',
      '#include <iostream>',
      '',
      'void countingSort(std::vector<int>& arr, bool ascending) {',
      '    if (arr.empty() || arr.size() == 1) return;',
      '',
      '    int minVal = *std::min_element(arr.begin(), arr.end());',
      '    int maxVal = *std::max_element(arr.begin(), arr.end());',
      '    int range = maxVal - minVal + 1;',
      '',
      '    std::vector<int> count(range, 0);',
      '    std::vector<int> output(arr.size());',
      '',
      '    for (int x : arr) {',
      '        count[x - minVal]++;',
      '    }',
      '',
      '    for (int i = 1; i < range; i++) {',
      '        count[i] += count[i - 1];',
      '    }',
      '',
      '    for (int i = arr.size() - 1; i >= 0; i--) {',
      '        output[count[arr[i] - minVal] - 1] = arr[i];',
      '        count[arr[i] - minVal]--;',
      '    }',
      '',
      '    if (!ascending) {',
      '        std::reverse(output.begin(), output.end());',
      '    }',
      '    arr = output;',
      '}',
    ],
    python: [
      'def countingSort(arr, ascending=True):',
      '    if not arr or len(arr) <= 1:',
      '        return # Modifies arr in-place, no explicit return needed for that',
      '',
      '    min_val = min(arr)',
      '    max_val = max(arr)',
      '    range_of_elements = max_val - min_val + 1',
      '',
      '    count = [0] * range_of_elements',
      '    output = [0] * len(arr)',
      '',
      '    for num in arr:',
      '        count[num - min_val] += 1',
      '',
      '    for i in range(1, len(count)):',
      '        count[i] += count[i - 1]',
      '    for i in range(len(arr) - 1, -1, -1):',
      '        output[count[arr[i] - min_val] - 1] = arr[i]',
      '        count[arr[i] - min_val] -= 1',
      '    if not ascending:',
      '        output.reverse()',
      '',
      '    # Copy sorted output back to original array',
      '    for i in range(len(arr)):',
      '        arr[i] = output[i]',
      '    # No explicit return needed if modifying in-place',
    ],
  },
  pseudoCodeMapping: {
    0: { c: [6], cpp: [5], python: [1] },
    1: { c: [7], cpp: [6], python: [2] },
    2: { c: [7], cpp: [6], python: [3] },
    3: { c: [7], cpp: [6], python: [3] },
    5: { c: [9], cpp: [10], python: [7] },
    6: { c: [10, 17], cpp: [12], python: [9] },
    8: { c: [19], cpp: [15], python: [12] },
    9: { c: [20], cpp: [16], python: [13] },
    10: { c: [21], cpp: [17], python: [13] },
    12: { c: [24], cpp: [19], python: [16] },
    13: { c: [25], cpp: [20], python: [17] },
    14: { c: [26], cpp: [21], python: [17] },
    16: { c: [11], cpp: [13], python: [10] },
    17: { c: [27], cpp: [23], python: [20] },
    18: { c: [27], cpp: [23], python: [20] },
    19: { c: [28], cpp: [24], python: [21] },
    20: { c: [28], cpp: [24], python: [21] },
    21: { c: [29], cpp: [25], python: [22] },
    22: { c: [30], cpp: [26], python: [22] },
    24: { c: [31], cpp: [28], python: [24] },
    25: { cpp: [29], python: [25] },
    26: { c: [44], cpp: [30], python: [25] },
    28: { c: [47], cpp: [32], python: [28] },
    29: { c: [48], cpp: [32], python: [28] },
    30: { c: [49], cpp: [33], python: [28] },
    31: { c: [52], cpp: [33], python: [28] },
  },
  performancePaths: {
    best: [0, 1, 2, 3, 5, 6, 8, 9, 10, 12, 13, 14, 16, 17, 18, 19, 20, 21, 22, 28, 29, 30, 31],
    average: [
      0, 1, 2, 3, 5, 6, 8, 9, 10, 12, 13, 14, 16, 17, 18, 19, 20, 21, 22, 24, 25, 26, 28, 29, 30,
      31,
    ],
    worst: [
      0, 1, 2, 3, 5, 6, 8, 9, 10, 12, 13, 14, 16, 17, 18, 19, 20, 21, 22, 24, 25, 26, 28, 29, 30,
      31,
    ],
  },
}
