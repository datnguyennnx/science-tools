'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { timSortGenerator } from '../algorithms'

export const timSortData: SortAlgorithm = {
  id: 'timSort',
  name: 'Tim Sort',
  description:
    'Created by Tim Peters in 2002 for the Python programming language, Tim Sort is a highly optimized hybrid stable sorting algorithm derived from Merge Sort and Insertion Sort. It is designed to perform well on many kinds of real-world data by taking advantage of naturally occurring runs (already sorted subsequences) within the data. It identifies these runs and merges them efficiently using a modified merge process. Tim Sort is the standard sorting algorithm in Python, Java, and other languages due to its excellent performance on typical datasets.',
  generator: timSortGenerator,
  complexity: {
    time: { best: 'O(n)', average: 'O(n log n)', worst: 'O(n log n)' },
    space: 'O(n)',
  },
  origin: { name: 'Tim Peters', year: 2002 },
  img: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRzFnR9nKrRMRga3k5z444lnItT-GYEIkO2ow&s',
  pseudoCodes: {
    plaintext: [
      'procedure timSort(list)',
      '  n = length of list',
      '  MIN_RUN = 32 // Or calculate dynamically',
      '',
      '  // Phase 1: Sort individual runs of size MIN_RUN',
      '  for i = 0 to n - 1 step MIN_RUN',
      '    left = i',
      '    right = min(i + MIN_RUN - 1, n - 1)',
      '    insertionSort(list, left, right) // Sort the run',
      '  end for',
      '',
      '  // Phase 2: Merge sorted runs',
      '  size = MIN_RUN',
      '  while size < n',
      '    for left = 0 to n - 1 step 2 * size',
      '      mid = left + size - 1',
      '      right = min((left + 2 * size - 1), (n - 1))',
      '      if mid < right then // If there is a second run to merge with',
      '        merge(list, left, mid, right)',
      '      end if',
      '    end for',
      '    size = 2 * size',
      '  end while',
      'end procedure',
      '',
      '// Helper: insertionSort(list, left, right) - Sorts the sub-array list[left...right] in place.',
      '// The sort order (ascending/descending) of this helper determines the order of sorted runs.',
      '// Helper: merge(list, left, mid, right) - Merges two sorted sub-arrays: list[left...mid] and list[mid+1...right].',
      '// The merge logic (e.g., comparison for ascending/descending) determines the final sorted order.',
    ],
    c: [
      '#define MIN_RUN 32',
      '',
      '// Assume: void insertionSort(int arr[], int left, int right); exists',
      '// Assume: void merge(int arr[], int l, int m, int r); exists',
      '',
      'void timSort(int arr[], int n) {',
      '  if (n <= 1) return;',
      '  for (int i = 0; i < n; i += MIN_RUN) {',
      '    int left = i;',
      '    int right = (i + MIN_RUN - 1 < n - 1) ? (i + MIN_RUN - 1) : (n - 1);',
      '    insertionSort(arr, left, right);',
      '  }',
      '',
      '  for (int size = MIN_RUN; size < n; size = 2 * size) {',
      '    for (int left = 0; left < n; left += 2 * size) {',
      '      int mid = (left + size - 1 < n - 1) ? (left + size - 1) : (n - 1);',
      '      int right = (left + 2 * size - 1 < n - 1) ? (left + 2 * size - 1) : (n - 1);',
      '      if (mid < right) {',
      '         merge(arr, left, mid, right);',
      '      }',
      '    }',
      '  }',
      '}',
    ],
    cpp: [
      '#include <algorithm> // For std::min',
      '',
      'const int MIN_RUN = 32;',
      '',
      '// Assume: void insertionSort(int arr[], int left, int right); exists',
      '// Assume: void merge(int arr[], int l, int m, int r); // Merges arr[l..m] and arr[m+1..r]',
      '',
      'void timSort(int arr[], int n) {',
      '  if (n <= 1) return;',
      '',
      '  // Phase 1: Sort individual runs',
      '  for (int i = 0; i < n; i += MIN_RUN) {',
      '    int left = i;',
      '    int right = std::min(i + MIN_RUN - 1, n - 1);',
      '    insertionSort(arr, left, right);',
      '  }',
      '',
      '  // Phase 2: Merge runs',
      '  for (int size = MIN_RUN; size < n; size = 2 * size) {',
      '    for (int left = 0; left < n; left += 2 * size) {',
      '      int mid = std::min(left + size - 1, n - 1);',
      '      int right = std::min(left + 2 * size - 1, n - 1);',
      '      if (mid < right) {',
      '        merge(arr, left, mid, right);',
      '      }',
      '    }',
      '  }',
      '}',
    ],
    python: [
      'MIN_RUN = 32',
      '',
      '# Assume: def insertion_sort_range(arr, left, right): ... exists',
      '# Assume: def merge_ranges(arr, l, m, r): ... exists',
      '',
      'def tim_sort(arr):',
      '  n = len(arr)',
      '  if n <= 1:',
      '    return',
      '',
      '  # Phase 1: Sort individual runs',
      '  for i in range(0, n, MIN_RUN):',
      '    left = i',
      '    right = min(i + MIN_RUN - 1, n - 1)',
      '    insertion_sort_range(arr, left, right)',
      '',
      '  # Phase 2: Merge runs',
      '  size = MIN_RUN',
      '  while size < n:',
      '    for left in range(0, n, 2 * size):',
      '      mid = min(left + size - 1, n - 1)',
      '      right = min(left + 2 * size - 1, n - 1)',
      '      if mid < right:',
      '        merge_ranges(arr, left, mid, right)',
      '    size *= 2',
    ],
  },
}
