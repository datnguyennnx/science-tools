'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { timSortGenerator } from '../algorithms'

export const timSortData: SortAlgorithm = {
  id: 'timSort',
  name: 'Tim Sort',
  description:
    'Created by Tim Peters in 2002 for the Python programming language, Tim Sort is a highly optimized hybrid stable sorting algorithm derived from Merge Sort and Insertion Sort. It is designed to perform well on many kinds of real-world data by taking advantage of naturally occurring runs (already sorted subsequences) within the data. It identifies these runs and merges them efficiently using a modified merge process. Tim Sort is the standard sorting algorithm in Python, Java, and other languages due to its excellent performance on typical datasets.',
  generator: timSortGenerator,
  complexity: {
    time: { best: 'O(n)', average: 'O(n log n)', worst: 'O(n log n)' },
    space: 'O(n)',
  },
  origin: { name: 'Tim Peters', year: 2002 },
  img: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRzFnR9nKrRMRga3k5z444lnItT-GYEIkO2ow&s',
  pseudoCodes: {
    plaintext: [
      'procedure timSort(list, direction)',
      '  n = length of list',
      '  MIN_RUN = 32',
      '',
      '  for i = 0 to n - 1 step MIN_RUN',
      '    left = i',
      '    right = min(i + MIN_RUN - 1, n - 1)',
      '    insertionSort(list, left, right, direction)',
      '  end for',
      '',
      '  size = MIN_RUN',
      '  while size < n',
      '    for left = 0 to n - 1 step 2 * size',
      '      mid = left + size - 1',
      '      right = min((left + 2 * size - 1), (n - 1))',
      '      if mid < right then',
      '        merge(list, left, mid, right, direction)',
      '      end if',
      '    end for',
      '    size = 2 * size',
      '  end while',
      'end procedure',
    ],
    c: [
      '#define MIN_RUN 32',
      '#include <stdbool.h>',
      '',
      '// Assume insertionSort and merge are defined elsewhere and handle ascending/descending',
      'void timSort(int arr[], int n, bool ascending) {',
      '  if (n <= 1) return;',
      '  for (int i = 0; i < n; i += MIN_RUN) {',
      '    int left = i;',
      '    int right = (i + MIN_RUN - 1 < n - 1) ? (i + MIN_RUN - 1) : (n - 1);',
      '    insertionSort(arr, left, right, ascending);',
      '  }',
      '',
      '  for (int size = MIN_RUN; size < n; size = 2 * size) {',
      '    for (int left = 0; left < n; left += 2 * size) {',
      '      int mid = (left + size - 1 < n - 1) ? (left + size - 1) : (n - 1);',
      '      int right = (left + 2 * size - 1 < n - 1) ? (left + 2 * size - 1) : (n - 1);',
      '      if (mid < right) {',
      '         merge(arr, left, mid, right, ascending);',
      '      }',
      '    }',
      '  }',
      '}',
    ],
    cpp: [
      '#include <algorithm>',
      '#include <stdbool.h>',
      '',
      'const int MIN_RUN = 32;',
      '',
      '// Assume insertionSort and merge are defined elsewhere and handle ascending/descending',
      'void timSort(int arr[], int n, bool ascending) {',
      '  if (n <= 1) return;',
      '',
      '  for (int i = 0; i < n; i += MIN_RUN) {',
      '    int left = i;',
      '    int right = std::min(i + MIN_RUN - 1, n - 1);',
      '    insertionSort(arr, left, right, ascending);',
      '  }',
      '',
      '  for (int size = MIN_RUN; size < n; size = 2 * size) {',
      '    for (int left = 0; left < n; left += 2 * size) {',
      '      int mid = std::min(left + size - 1, n - 1);',
      '      int right = std::min(left + 2 * size - 1, n - 1);',
      '      if (mid < right) {',
      '        merge(arr, left, mid, right, ascending);',
      '      }',
      '    }',
      '  }',
      '}',
    ],
    python: [
      'MIN_RUN = 32',
      '',
      '# Assume insertion_sort_range and merge_ranges are defined elsewhere and handle ascending/descending',
      'def tim_sort(arr, ascending=True):',
      '  n = len(arr)',
      '  if n <= 1:',
      '    return arr # Modified to return arr for consistency if n <= 1',
      '',
      '  for i in range(0, n, MIN_RUN):',
      '    left = i',
      '    right = min(i + MIN_RUN - 1, n - 1)',
      '    insertion_sort_range(arr, left, right, ascending)',
      '',
      '  size = MIN_RUN',
      '  while size < n:',
      '    for left in range(0, n, 2 * size):',
      '      mid = min(left + size - 1, n - 1)',
      '      right = min(left + 2 * size - 1, n - 1)',
      '      if mid < right:',
      '        merge_ranges(arr, left, mid, right, ascending)',
      '    size *= 2',
      '  return arr # Added return arr for sorted array',
    ],
  },
  pseudoCodeMapping: {
    0: { c: [2], cpp: [4], python: [2] },
    1: { python: [3] },
    2: { c: [0], cpp: [2], python: [0] },
    4: { c: [4], cpp: [7], python: [7] },
    5: { c: [5], cpp: [8], python: [8] },
    6: { c: [6], cpp: [9], python: [9] },
    7: { c: [7], cpp: [10], python: [10] },
    8: { c: [8], cpp: [11], python: [7] },
    10: { c: [10], cpp: [13], python: [12] },
    11: { c: [10], cpp: [13], python: [13] },
    12: { c: [11], cpp: [14], python: [14] },
    13: { c: [12], cpp: [15], python: [15] },
    14: { c: [13], cpp: [16], python: [16] },
    15: { c: [14], cpp: [17], python: [17] },
    16: { c: [15], cpp: [18], python: [18] },
    17: { c: [16], cpp: [19], python: [17] },
    18: { c: [17], cpp: [20], python: [14] },
    19: { c: [10], cpp: [13], python: [19] },
    20: { c: [18], cpp: [21], python: [13] },
    21: { c: [19], cpp: [22], python: [2] },
  },
  hasAdvancedAuxiliaryVisuals: false,
}
