import type { SortAlgorithm } from '../algorithmRegistry'

const rawPlaintextPseudoCode = [
  'procedure timSort(list, direction)',
  '  n = length of list',
  '  MIN_RUN = 32',
  '',
  '  for i = 0 to n - 1 step MIN_RUN',
  '    left = i',
  '    right = min(i + MIN_RUN - 1, n - 1)',
  '    insertionSort(list, left, right, direction)',
  '  end for',
  '',
  '  size = MIN_RUN',
  '  while size < n',
  '    for left = 0 to n - 1 step 2 * size',
  '      mid = left + size - 1',
  '      right = min((left + 2 * size - 1), (n - 1))',
  '      if mid < right then',
  '        merge(list, left, mid, right, direction)',
  '      end if',
  '    end for',
  '    size = 2 * size',
  '  end while',
  'end procedure',
]

export const timSortData: SortAlgorithm = {
  id: 'timSort',
  name: 'Timsort',
  description:
    'Timsort is a hybrid stable sorting algorithm, derived from merge sort and insertion sort, designed to perform well on many kinds of real-world data. It was invented by Tim Peters in 2002 for use in the Python programming language. The algorithm finds subsequences of the data that are already ordered (runs) and uses them to sort the remainder more efficiently. This is done by merging runs until only one run remains. If the array is small, or runs are small, insertion sort is used.',
  complexity: {
    time: { best: 'O(n)', average: 'O(n log n)', worst: 'O(n log n)' },
    space: 'O(n)',
  },
  origin: { name: 'Tim Peters', year: 2002 },
  img: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRzFnR9nKrRMRga3k5z444lnItT-GYEIkO2ow&s',
  pseudoCode: rawPlaintextPseudoCode,
  languageExamples: {
    c: [
      '#include <stdlib.h>',
      '#include <stdbool.h>',
      '#include <string.h>',
      '',
      '#define MIN_MERGE 32',
      '',
      'void insertionSort(int arr[], int left, int right, bool ascending) {',
      '    for (int i = left + 1; i <= right; i++) {',
      '        int temp = arr[i];',
      '        int j = i - 1;',
      '        if (ascending) {',
      '            while (j >= left && arr[j] > temp) {',
      '                arr[j + 1] = arr[j];',
      '                j--;',
      '            }',
      '        } else {',
      '            while (j >= left && arr[j] < temp) {',
      '                arr[j + 1] = arr[j];',
      '                j--;',
      '            }',
      '        }',
      '        arr[j + 1] = temp;',
      '    }',
      '}',
      '',
      'void merge(int arr[], int l, int m, int r, bool ascending) {',
      '    int len1 = m - l + 1, len2 = r - m;',
      '    int* left_arr = (int*)malloc(len1 * sizeof(int));',
      '    int* right_arr = (int*)malloc(len2 * sizeof(int));',
      '',
      '    if (!left_arr || !right_arr) {',
      '        if(left_arr) free(left_arr);',
      '        if(right_arr) free(right_arr);',
      '        return;',
      '    }',
      '',
      '    memcpy(left_arr, &arr[l], len1 * sizeof(int));',
      '    memcpy(right_arr, &arr[m + 1], len2 * sizeof(int));',
      '',
      '    int i = 0, j = 0, k = l;',
      '',
      '    while (i < len1 && j < len2) {',
      '        bool take_left;',
      '        if (ascending) {',
      '            take_left = (left_arr[i] <= right_arr[j]);',
      '        } else {',
      '            take_left = (left_arr[i] >= right_arr[j]);',
      '        }',
      '        if (take_left) {',
      '            arr[k++] = left_arr[i++];',
      '        } else {',
      '            arr[k++] = right_arr[j++];',
      '        }',
      '    }',
      '',
      '    while (i < len1) arr[k++] = left_arr[i++];',
      '    while (j < len2) arr[k++] = right_arr[j++];',
      '',
      '    free(left_arr);',
      '    free(right_arr);',
      '}',
      '',
      'void timSort(int arr[], int n, bool ascending) {',
      '    if (n <= 1) return;',
      '    for (int i = 0; i < n; i += MIN_MERGE) {',
      '        insertionSort(arr, i, (i + MIN_MERGE - 1 < n - 1) ? (i + MIN_MERGE - 1) : (n - 1), ascending);',
      '    }',
      '',
      '    for (int size = MIN_MERGE; size < n; size = 2 * size) {',
      '        for (int left = 0; left < n; left += 2 * size) {',
      '            int mid = left + size - 1;',
      '            int right = (left + 2 * size - 1 < n - 1) ? (left + 2 * size - 1) : (n - 1);',
      '            if (mid < right) {',
      '                merge(arr, left, mid, right, ascending);',
      '            }',
      '        }',
      '    }',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <algorithm>',
      '',
      'const int CPP_MIN_MERGE = 32;',
      '',
      'template <typename T>',
      'void insertionSort(std::vector<T>& arr, int left, int right, bool ascending) {',
      '    for (int i = left + 1; i <= right; i++) {',
      '        T temp = arr[i];',
      '        int j = i - 1;',
      '        if (ascending) {',
      '            while (j >= left && arr[j] > temp) {',
      '                arr[j + 1] = arr[j];',
      '                j--;',
      '            }',
      '        } else {',
      '            while (j >= left && arr[j] < temp) {',
      '                arr[j + 1] = arr[j];',
      '                j--;',
      '            }',
      '        }',
      '        arr[j + 1] = temp;',
      '    }',
      '}',
      '',
      'template <typename T>',
      'void merge(std::vector<T>& arr, int l, int m, int r, bool ascending) {',
      '    int len1 = m - l + 1;',
      '    int len2 = r - m;',
      '    std::vector<T> left_arr(len1);',
      '    std::vector<T> right_arr(len2);',
      '',
      '    std::copy(arr.begin() + l, arr.begin() + l + len1, left_arr.begin());',
      '    std::copy(arr.begin() + m + 1, arr.begin() + m + 1 + len2, right_arr.begin());',
      '',
      '    int i = 0, j = 0, k = l;',
      '',
      '    while (i < len1 && j < len2) {',
      '        bool take_left;',
      '        if (ascending) {',
      '            take_left = (left_arr[i] <= right_arr[j]);',
      '        } else {',
      '            take_left = (left_arr[i] >= right_arr[j]);',
      '        }',
      '        if (take_left) {',
      '            arr[k++] = left_arr[i++];',
      '        } else {',
      '            arr[k++] = right_arr[j++];',
      '        }',
      '    }',
      '',
      '    while (i < len1) arr[k++] = left_arr[i++];',
      '    while (j < len2) arr[k++] = right_arr[j++];',
      '}',
      '',
      'template <typename T>',
      'void timSort(std::vector<T>& arr, bool ascending) {',
      '    int n = arr.size();',
      '    if (n <= 1) return;',
      '',
      '    for (int i = 0; i < n; i += CPP_MIN_MERGE) {',
      '        insertionSort(arr, i, std::min((i + CPP_MIN_MERGE - 1), (n - 1)), ascending);',
      '    }',
      '',
      '    for (int size = CPP_MIN_MERGE; size < n; size = 2 * size) {',
      '        for (int left = 0; left < n; left += 2 * size) {',
      '            int mid = left + size - 1;',
      '            int right = std::min((left + 2 * size - 1), (n - 1));',
      '            if (mid < right) {',
      '                merge(arr, left, mid, right, ascending);',
      '            }',
      '        }',
      '    }',
      '}',
    ],
    python: [
      'MIN_RUN = 32',
      '',
      'def insertion_sort_for_tim(arr, left, right, ascending=True):',
      '    for i in range(left + 1, right + 1):',
      '        temp = arr[i]',
      '        j = i - 1',
      '        if ascending:',
      '            while j >= left and arr[j] > temp:',
      '                arr[j + 1] = arr[j]',
      '                j -= 1',
      '        else:  # descending',
      '            while j >= left and arr[j] < temp:',
      '                arr[j + 1] = arr[j]',
      '                j -= 1',
      '        arr[j + 1] = temp',
      '',
      'def merge_for_tim(arr, l, m, r, ascending=True):',
      '    len1, len2 = m - l + 1, r - m',
      '    left_arr = [0] * len1',
      '    right_arr = [0] * len2',
      '    for i in range(len1):',
      '        left_arr[i] = arr[l + i]',
      '    for i in range(len2):',
      '        right_arr[i] = arr[m + 1 + i]',
      '',
      '    i, j, k = 0, 0, l',
      '    while i < len1 and j < len2:',
      '        take_left = False',
      '        if ascending:',
      '            if left_arr[i] <= right_arr[j]:',
      '                take_left = True',
      '        else:  # descending',
      '            if left_arr[i] >= right_arr[j]:',
      '                take_left = True',
      '        ',
      '        if take_left:',
      '            arr[k] = left_arr[i]',
      '            i += 1',
      '        else:',
      '            arr[k] = right_arr[j]',
      '            j += 1',
      '        k += 1',
      '',
      '    while i < len1:',
      '        arr[k] = left_arr[i]',
      '        i += 1',
      '        k += 1',
      '    while j < len2:',
      '        arr[k] = right_arr[j]',
      '        j += 1',
      '        k += 1',
      '',
      'def tim_sort(arr, ascending=True):',
      '    n = len(arr)',
      '    if n <= 1:',
      '        return arr',
      '',
      '    # Sort individual subarrays of size MIN_RUN',
      '    for i in range(0, n, MIN_RUN):',
      '        left = i',
      '        right = min(i + MIN_RUN - 1, n - 1)',
      '        insertion_sort_for_tim(arr, left, right, ascending)',
      '',
      '    # Start merging from size MIN_RUN',
      '    size = MIN_RUN',
      '    while size < n:',
      '        for left in range(0, n, 2 * size):',
      '            mid = left + size - 1',
      '            right = min((left + 2 * size - 1), (n - 1))',
      '',
      '            if mid < right:',
      '                merge_for_tim(arr, left, mid, right, ascending)',
      '        size *= 2',
      '    return arr',
    ],
  },
  pseudoCodeMapping: {
    0: { c: [59], cpp: [50], python: [50] },
    1: { c: [60], cpp: [51], python: [51] },
    2: { c: [5], cpp: [4], python: [1] },
    4: { c: [61], cpp: [54], python: [56] },
    5: { c: [62], cpp: [55], python: [57] },
    6: { c: [62], cpp: [55], python: [58] },
    7: { c: [62], cpp: [55], python: [59] },
    8: { c: [61], cpp: [54], python: [56] },
    10: { c: [64], cpp: [57], python: [62] },
    11: { c: [64], cpp: [57], python: [63] },
    12: { c: [65], cpp: [58], python: [64] },
    13: { c: [66], cpp: [59], python: [65] },
    14: { c: [67], cpp: [60], python: [66] },
    15: { c: [68], cpp: [61], python: [68] },
    16: { c: [69], cpp: [62], python: [69] },
    17: { c: [68], cpp: [61], python: [68] },
    18: { c: [65], cpp: [58], python: [64] },
    19: { c: [64], cpp: [57], python: [70] },
    20: { c: [64], cpp: [57], python: [63] },
    21: { c: [73], cpp: [66], python: [71] },
  },
  performancePaths: {
    best: [0, 1, 2, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21],
    worst: [0, 1, 2, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21],
    average: [0, 1, 2, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21],
  },
}
