'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { oddEvenSortGenerator } from '../algorithms'

const rawPlaintextPseudoCode = [
  'procedure oddEvenSort(list, direction)',
  '  n = length of list',
  '  if n <= 1 then return list',
  '  isSorted = false',
  '  while not isSorted',
  '    isSorted = true',
  '    for i = 1 to n - 2 step 2',
  '      if (direction == ASC and list[i] > list[i + 1]) or (direction == DESC and list[i] < list[i + 1]) then',
  '        swap(list[i], list[i + 1])',
  '        isSorted = false',
  '      end if',
  '    end for',
  '    for i = 0 to n - 2 step 2',
  '      if (direction == ASC and list[i] > list[i + 1]) or (direction == DESC and list[i] < list[i + 1]) then',
  '        swap(list[i], list[i + 1])',
  '        isSorted = false',
  '      end if',
  '    end for',
  '  end while',
  '  return list',
  'end procedure',
]

export const oddEvenSortData: SortAlgorithm = {
  id: 'oddEvenSort',
  name: 'Odd-Even Sort',
  description:
    'Odd-Even Sort, also known as brick sort, is a simple sorting algorithm that is a variation of Bubble Sort. It is primarily designed for use on parallel processors. The algorithm repeatedly performs two phases: an odd phase where odd-indexed pairs of adjacent elements are compared and swapped if out of order, and an even phase where even-indexed pairs are compared and swapped. This alternating comparison and swapping process continues until the list is sorted.',
  generator: oddEvenSortGenerator,
  complexity: { time: { best: 'O(n)', average: 'O(n^2)', worst: 'O(n^2)' }, space: 'O(1)' },
  origin: { name: 'N. Habermann', year: 1972 },
  img: '',
  pseudoCode: rawPlaintextPseudoCode,
  languageExamples: {
    c: [
      '#include <stdbool.h>',
      '',
      'void swap(int* a, int* b) {',
      '    int temp = *a;',
      '    *a = *b;',
      '    *b = temp;',
      '}',
      '',
      'void oddEvenSort(int arr[], int n, bool ascending) {',
      '    if (n <= 1) return;',
      '    bool isSorted = false;',
      '    while (!isSorted) {',
      '        isSorted = true;',
      '        for (int i = 1; i <= n - 2; i = i + 2) {',
      '            bool shouldSwap;',
      '            if (ascending) {',
      '                shouldSwap = (arr[i] > arr[i + 1]);',
      '            } else {',
      '                shouldSwap = (arr[i] < arr[i + 1]);',
      '            }',
      '            if (shouldSwap) {',
      '                swap(&arr[i], &arr[i + 1]);',
      '                isSorted = false;',
      '            }',
      '        }',
      '        for (int i = 0; i <= n - 2; i = i + 2) {',
      '             bool shouldSwap;',
      '            if (ascending) {',
      '                shouldSwap = (arr[i] > arr[i + 1]);',
      '            } else {',
      '                shouldSwap = (arr[i] < arr[i + 1]);',
      '            }',
      '            if (shouldSwap) {',
      '                swap(&arr[i], &arr[i + 1]);',
      '                isSorted = false;',
      '            }',
      '        }',
      '    }',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <utility> // For std::swap',
      '#include <stdbool.h>',
      '',
      'template <typename T>',
      'void oddEvenSort(std::vector<T>& arr, bool ascending) {',
      '    int n = arr.size();',
      '    if (n <= 1) return;',
      '    bool isSorted = false;',
      '    while (!isSorted) {',
      '        isSorted = true;',
      '        for (int i = 1; i <= n - 2; i = i + 2) {',
      '            bool shouldSwap;',
      '            if (ascending) {',
      '                shouldSwap = (arr[i] > arr[i + 1]);',
      '            } else {',
      '                shouldSwap = (arr[i] < arr[i + 1]);',
      '            }',
      '            if (shouldSwap) {',
      '                std::swap(arr[i], arr[i + 1]);',
      '                isSorted = false;',
      '            }',
      '        }',
      '        for (int i = 0; i <= n - 2; i = i + 2) {',
      '            bool shouldSwap;',
      '            if (ascending) {',
      '                shouldSwap = (arr[i] > arr[i + 1]);',
      '            } else {',
      '                shouldSwap = (arr[i] < arr[i + 1]);',
      '            }',
      '            if (shouldSwap) {',
      '                std::swap(arr[i], arr[i + 1]);',
      '                isSorted = false;',
      '            }',
      '        }',
      '    }',
      '}',
    ],
    python: [
      'def odd_even_sort(arr, ascending=True):',
      '    n = len(arr)',
      '    if n <= 1:',
      '        return arr',
      '    is_sorted = False',
      '    while not is_sorted:',
      '        is_sorted = True',
      '        for i in range(1, n - 1, 2):',
      '            should_swap = False',
      '            if ascending:',
      '                if arr[i] > arr[i+1]:',
      '                    should_swap = True',
      '            else: # descending',
      '                if arr[i] < arr[i+1]:',
      '                    should_swap = True',
      '            ',
      '            if should_swap:',
      '                arr[i], arr[i+1] = arr[i+1], arr[i]',
      '                is_sorted = False',
      '        ',
      '        for i in range(0, n - 1, 2):',
      '            should_swap = False',
      '            if ascending:',
      '                if arr[i] > arr[i+1]:',
      '                    should_swap = True',
      '            else: # descending',
      '                if arr[i] < arr[i+1]:',
      '                    should_swap = True',
      '',
      '            if should_swap:',
      '                arr[i], arr[i+1] = arr[i+1], arr[i]',
      '                is_sorted = False',
      '    return arr',
    ],
  },
  pseudoCodeMapping: {
    0: { c: [9], cpp: [6], python: [1] },
    1: { c: [10], cpp: [7], python: [2] },
    2: { c: [10], cpp: [8], python: [3, 4] },
    3: { c: [11], cpp: [9], python: [6] },
    4: { c: [12], cpp: [10], python: [7] },
    5: { c: [13], cpp: [11], python: [8] },
    6: { c: [15], cpp: [13], python: [10] },
    7: { c: [16, 17, 18, 19, 20], cpp: [14, 15, 16, 17, 18], python: [11, 12, 13, 14, 15, 16, 17] },
    8: { c: [22], cpp: [20], python: [20] },
    9: { c: [23], cpp: [21], python: [21] },
    10: { c: [24], cpp: [22], python: [21] },
    11: { c: [25], cpp: [23], python: [21] },
    12: { c: [27], cpp: [25], python: [24] },
    13: {
      c: [28, 29, 30, 31, 32],
      cpp: [26, 27, 28, 29, 30],
      python: [25, 26, 27, 28, 29, 30, 31],
    },
    14: { c: [34], cpp: [32], python: [34] },
    15: { c: [35], cpp: [33], python: [35] },
    16: { c: [36], cpp: [34], python: [35] },
    17: { c: [37], cpp: [35], python: [35] },
    18: { c: [38], cpp: [36], python: [7] },
    19: { c: [39], cpp: [37], python: [36] },
    20: { c: [39], cpp: [37], python: [36] },
  },
  performancePaths: {
    best: [0, 1, 2, 3, 4, 5, 6, 7, 10, 11, 12, 13, 16, 17, 18, 19, 20],
    worst: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
    average: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
  },
  hasAdvancedAuxiliaryVisuals: false,
}
