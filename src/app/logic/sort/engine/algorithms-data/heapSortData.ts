'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { heapSortGenerator } from '../algorithms'

export const heapSortData: SortAlgorithm = {
  id: 'heapSort',
  name: 'Heap Sort',
  description:
    'Invented by J. W. J. Williams in 1964, Heap Sort is a comparison-based sorting algorithm that leverages the heap data structure. It first builds a max-heap (for ascending sort; a min-heap for descending sort) from the input array, where the largest (or smallest) element is at the root. Then, it repeatedly extracts the maximum (or minimum) element from the heap and places it at the end (or beginning for some descending variations) of the array, rebuilding the heap with the remaining elements. This process continues until the array is sorted. A key advantage is its O(1) space complexity for typical implementations, performing the sort in-place.',
  generator: heapSortGenerator,
  complexity: {
    time: { best: 'O(n log n)', average: 'O(n log n)', worst: 'O(n log n)' },
    space: 'O(1)',
  },
  origin: { name: 'J. W. J. Williams', year: 1964 },
  img: 'https://ottawacitizen.remembering.ca/_next/image?url=https%3A%2F%2Fd1q40j6jx1d8h6.cloudfront.net%2FObituaries%2F41508162%2FThumbnail_1.jpg&w=3840&q=75',
  pseudoCodes: {
    plaintext: [
      'procedure heapSort(list, direction)',
      '  n = length of list',
      '  if n <= 1 then return',
      '',
      '  for i = floor(n / 2) - 1 down to 0',
      '    heapify(list, n, i, direction)',
      '  end for',
      '',
      '  for i = n - 1 down to 1',
      '    swap(list[0], list[i])',
      '    heapify(list, i, 0, direction)',
      '  end for',
      'end procedure',
      '',
      'procedure heapify(list, heapSize, rootIndex, direction)',
      '  extremeElementIndex = rootIndex',
      '  left = 2 * rootIndex + 1',
      '  right = 2 * rootIndex + 2',
      '',
      '  if left < heapSize then',
      '    if (direction == ASC and list[left] > list[extremeElementIndex]) or ',
      '       (direction == DESC and list[left] < list[extremeElementIndex]) then',
      '      extremeElementIndex = left',
      '    end if',
      '  end if',
      '',
      '  if right < heapSize then',
      '    if (direction == ASC and list[right] > list[extremeElementIndex]) or ',
      '       (direction == DESC and list[right] < list[extremeElementIndex]) then',
      '      extremeElementIndex = right',
      '    end if',
      '  end if',
      '',
      '  if extremeElementIndex != rootIndex then',
      '    swap(list[rootIndex], list[extremeElementIndex])',
      '    heapify(list, heapSize, extremeElementIndex, direction)',
      '  end if',
      'end procedure',
    ],
    c: [
      '#include <stdbool.h>',
      '',
      'typedef enum { ASC, DESC } SortDirection;',
      '',
      'void swap(int* a, int* b) {',
      '  int temp = *a;',
      '  *a = *b;',
      '  *b = temp;',
      '}',
      '',
      'void heapify(int arr[], int n, int i, SortDirection direction) {',
      '  int extreme = i;',
      '  int left = 2 * i + 1;',
      '  int right = 2 * i + 2;',
      '',
      '  if (left < n) {',
      '    bool conditionMet = false;',
      '    if (direction == ASC && arr[left] > arr[extreme]) conditionMet = true;',
      '    else if (direction == DESC && arr[left] < arr[extreme]) conditionMet = true;',
      '    if (conditionMet) {',
      '      extreme = left;',
      '    }',
      '  }',
      '',
      '  if (right < n) {',
      '    bool conditionMet = false;',
      '    if (direction == ASC && arr[right] > arr[extreme]) conditionMet = true;',
      '    else if (direction == DESC && arr[right] < arr[extreme]) conditionMet = true;',
      '    if (conditionMet) {',
      '      extreme = right;',
      '    }',
      '  }',
      '',
      '  if (extreme != i) {',
      '    swap(&arr[i], &arr[extreme]);',
      '    heapify(arr, n, extreme, direction);',
      '  }',
      '}',
      '',
      'void heapSort(int arr[], int n, SortDirection direction) {',
      '  if (n <= 1) return;',
      '  for (int i = n / 2 - 1; i >= 0; i--) {',
      '    heapify(arr, n, i, direction);',
      '  }',
      '',
      '  for (int i = n - 1; i > 0; i--) {',
      '    swap(&arr[0], &arr[i]);',
      '    heapify(arr, i, 0, direction);',
      '  }',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <algorithm> // For std::swap',
      '',
      'enum class SortDirection { ASC, DESC };',
      '',
      'void heapify(std::vector<int>& arr, int n, int i, SortDirection direction) {',
      '  int extreme = i;',
      '  int left = 2 * i + 1;',
      '  int right = 2 * i + 2;',
      '',
      '  if (left < n) {',
      '    bool conditionMet = false;',
      '    if (direction == SortDirection::ASC && arr[left] > arr[extreme]) conditionMet = true;',
      '    else if (direction == SortDirection::DESC && arr[left] < arr[extreme]) conditionMet = true;',
      '    if (conditionMet) {',
      '      extreme = left;',
      '    }',
      '  }',
      '',
      '  if (right < n) {',
      '    bool conditionMet = false;',
      '    if (direction == SortDirection::ASC && arr[right] > arr[extreme]) conditionMet = true;',
      '    else if (direction == SortDirection::DESC && arr[right] < arr[extreme]) conditionMet = true;',
      '    if (conditionMet) {',
      '      extreme = right;',
      '    }',
      '  }',
      '',
      '  if (extreme != i) {',
      '    std::swap(arr[i], arr[extreme]);',
      '    heapify(arr, n, extreme, direction);',
      '  }',
      '}',
      '',
      'void heapSort(std::vector<int>& arr, SortDirection direction) {',
      '  int n = arr.size();',
      '  if (n <= 1) return;',
      '  for (int i = n / 2 - 1; i >= 0; i--) {',
      '    heapify(arr, n, i, direction);',
      '  }',
      '',
      '  for (int i = n - 1; i > 0; i--) {',
      '    std::swap(arr[0], arr[i]);',
      '    heapify(arr, i, 0, direction);',
      '  }',
      '}',
    ],
    python: [
      'def _heapify(arr, n, i, direction="asc"):',
      '  extreme = i',
      '  left = 2 * i + 1',
      '  right = 2 * i + 2',
      '',
      '  if left < n:',
      '    condition_met = False',
      '    if direction == "asc" and arr[left] > arr[extreme]:',
      '      condition_met = True',
      '    elif direction == "desc" and arr[left] < arr[extreme]:',
      '      condition_met = True',
      '    if condition_met:',
      '      extreme = left',
      '',
      '  if right < n:',
      '    condition_met = False',
      '    if direction == "asc" and arr[right] > arr[extreme]:',
      '      condition_met = True',
      '    elif direction == "desc" and arr[right] < arr[extreme]:',
      '      condition_met = True',
      '    if condition_met:',
      '      extreme = right',
      '',
      '  if extreme != i:',
      '    arr[i], arr[extreme] = arr[extreme], arr[i]',
      '    _heapify(arr, n, extreme, direction)',
      '',
      'def heap_sort(arr, direction="asc"):',
      '  n = len(arr)',
      '  if n <= 1:',
      '    return arr',
      '',
      '  for i in range(n // 2 - 1, -1, -1):',
      '    _heapify(arr, n, i, direction)',
      '',
      '  for i in range(n - 1, 0, -1):',
      '    arr[i], arr[0] = arr[0], arr[i]',
      '    _heapify(arr, i, 0, direction)',
      '  return arr',
    ],
  },
  pseudoCodeMapping: {
    0: { c: [36], cpp: [32], python: [26] },
    1: { c: [37], cpp: [33], python: [27] },
    2: { c: [37], cpp: [33], python: [28] },
    4: { c: [38], cpp: [34], python: [31] },
    5: { c: [39], cpp: [35], python: [32] },
    6: { c: [40], cpp: [36], python: [32] },
    8: { c: [42], cpp: [38], python: [34] },
    9: { c: [43], cpp: [39], python: [35] },
    10: { c: [44], cpp: [40], python: [36] },
    11: { c: [45], cpp: [41], python: [36] },
    12: { c: [46], cpp: [42], python: [37] },
    14: { c: [10], cpp: [5], python: [0] },
    15: { c: [11], cpp: [6], python: [1] },
    16: { c: [12], cpp: [7], python: [2] },
    17: { c: [13], cpp: [8], python: [3] },
    19: { c: [15], cpp: [10], python: [5] },
    20: { c: [16, 17, 18], cpp: [11, 12, 13], python: [7, 8, 9, 10] },
    21: { c: [16, 17, 18], cpp: [11, 12, 13], python: [7, 8, 9, 10] },
    22: { c: [19], cpp: [14], python: [12] },
    23: { c: [21], cpp: [16], python: [12] },
    24: { c: [21], cpp: [16], python: [12] },
    26: { c: [23], cpp: [18], python: [14] },
    27: { c: [24, 25, 26], cpp: [19, 20, 21], python: [16, 17, 18, 19] },
    28: { c: [24, 25, 26], cpp: [19, 20, 21], python: [16, 17, 18, 19] },
    29: { c: [27], cpp: [22], python: [21] },
    30: { c: [29], cpp: [24], python: [21] },
    31: { c: [29], cpp: [24], python: [21] },
    33: { c: [31], cpp: [26], python: [23] },
    34: { c: [32], cpp: [27], python: [24] },
    35: { c: [33], cpp: [28], python: [25] },
    36: { c: [34], cpp: [29], python: [25] },
    37: { c: [35], cpp: [30], python: [25] },
  },
  hasAdvancedAuxiliaryVisuals: false,
}
