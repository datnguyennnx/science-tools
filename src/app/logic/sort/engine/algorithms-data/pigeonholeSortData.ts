'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { pigeonholeSortGenerator } from '../algorithms'

const rawPlaintextPseudoCode = [
  'procedure pigeonholeSort(list, direction)',
  '  if length of list <= 1 then return list',
  '  minVal = findMinValue(list)',
  '  maxVal = findMaxValue(list)',
  '  range = maxVal - minVal + 1',
  '  create array of pigeonholes of size range, initially empty',
  '  for each element in list',
  '    add element to pigeonholes[element - minVal]',
  '  end for',
  '  index = 0',
  '  if direction is ASC then',
  '    for i = 0 to range - 1',
  '      for each element in pigeonholes[i]',
  '        list[index] = element',
  '        index = index + 1',
  '      end for',
  '    end for',
  '  else (direction is DESC)',
  '    for i = range - 1 down to 0',
  '      for each element in pigeonholes[i]',
  '        list[index] = element',
  '        index = index + 1',
  '      end for',
  '    end for',
  '  end if',
  '  return list',
  'end procedure',
]

export const pigeonholeSortData: SortAlgorithm = {
  id: 'pigeonholeSort',
  name: 'Pigeonhole Sort',
  description:
    "Pigeonhole Sort is a sorting algorithm that is suitable for sorting lists of elements where the number of elements (n) and the number of possible key values (N) are approximately the same. It requires O(n + N) time. It works by creating a number of 'pigeonholes' equal to the range of possible values. Each item is then placed into its corresponding pigeonhole. Finally, the elements are iterated over the pigeonholes in order to retrieve the sorted list.",
  generator: pigeonholeSortGenerator,
  complexity: { time: { best: 'O(n+N)', average: 'O(n+N)', worst: 'O(n+N)' }, space: 'O(N)' }, // N is range
  origin: { name: 'Known in early computing history for specific use cases' },
  img: '',
  pseudoCode: rawPlaintextPseudoCode,
  languageExamples: {
    c: [
      '#include <stdlib.h>',
      '#include <stdbool.h>',
      '',
      'typedef struct {',
      '    int* items;',
      '    int count;',
      '    int capacity;',
      '} PigeonholeList;',
      '',
      'PigeonholeList createPigeonholeList(int capacity) {',
      '    PigeonholeList pl;',
      '    pl.items = (int*)malloc(capacity * sizeof(int));',
      '    // Check for malloc failure',
      '    if (pl.items == NULL) {',
      '        pl.capacity = 0; // Indicate failure',
      '        pl.count = 0;',
      '        return pl;',
      '    }',
      '    pl.count = 0;',
      '    pl.capacity = capacity;',
      '    return pl;',
      '}',
      '',
      'void addToPigeonholeList(PigeonholeList* pl, int item) {',
      '    if (pl->items && pl->count < pl->capacity) { // Check if items is not NULL',
      '        pl->items[pl->count++] = item;',
      '    }',
      '}',
      '',
      'void pigeonholeSort(int arr[], int n, bool ascending) {',
      '    if (n <= 1) return;',
      '',
      '    int minVal = arr[0], maxVal = arr[0];',
      '    for (int i = 1; i < n; i++) {',
      '        if (arr[i] < minVal) minVal = arr[i];',
      '        if (arr[i] > maxVal) maxVal = arr[i];',
      '    }',
      '    int range = maxVal - minVal + 1;',
      '',
      '    PigeonholeList* pigeonholes = (PigeonholeList*)malloc(range * sizeof(PigeonholeList));',
      '    if (pigeonholes == NULL) return; // Malloc check for main pigeonholes array',
      '',
      '    for (int i = 0; i < range; i++) {',
      '        pigeonholes[i] = createPigeonholeList(n); // Max possible items in one hole is n',
      '        if (pigeonholes[i].capacity == 0 && n > 0) { // Check if createPigeonholeList failed',
      '            for (int k = 0; k < i; ++k) if(pigeonholes[k].items) free(pigeonholes[k].items);',
      '            free(pigeonholes);',
      '            return; // Critical error, cleanup and exit',
      '        }',
      '    }',
      '',
      '    for (int i = 0; i < n; i++) {',
      '        addToPigeonholeList(&pigeonholes[arr[i] - minVal], arr[i]);',
      '    }',
      '',
      '    int index = 0;',
      '    if (ascending) {',
      '        for (int i = 0; i < range; i++) {',
      '            for (int j = 0; j < pigeonholes[i].count; j++) {',
      '                arr[index++] = pigeonholes[i].items[j];',
      '            }',
      '        }',
      '    } else { // Descending',
      '        for (int i = range - 1; i >= 0; i--) {',
      '            for (int j = 0; j < pigeonholes[i].count; j++) {',
      '                // For stable descending sort, could iterate pigeonholes[i].items in reverse here if needed',
      '                arr[index++] = pigeonholes[i].items[j];',
      '            }',
      '        }',
      '    }',
      '',
      '    for (int i = 0; i < range; i++) {',
      '        if (pigeonholes[i].items) free(pigeonholes[i].items); // Check before freeing',
      '    }',
      '    free(pigeonholes);',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <algorithm> // For std::min_element, std::max_element',
      '',
      'template <typename T>',
      'void pigeonholeSort(std::vector<T>& arr, bool ascending) {',
      '    if (arr.empty() || arr.size() <= 1) return;',
      '',
      '    T minVal = *std::min_element(arr.begin(), arr.end());',
      '    T maxVal = *std::max_element(arr.begin(), arr.end());',
      '    int range = maxVal - minVal + 1;',
      '',
      '    std::vector<std::vector<T>> pigeonholes(range);',
      '',
      '    for (const T& element : arr) {',
      '        pigeonholes[element - minVal].push_back(element);',
      '    }',
      '',
      '    int index = 0;',
      '    if (ascending) {',
      '        for (int i = 0; i < range; ++i) {',
      '            for (const T& element : pigeonholes[i]) {',
      '                arr[index++] = element;',
      '            }',
      '        }',
      '    } else { // Descending',
      '        for (int i = range - 1; i >= 0; --i) {',
      '            for (const T& element : pigeonholes[i]) {',
      '                arr[index++] = element;',
      '            }',
      '        }',
      '    }',
      '}',
    ],
    python: [
      'def pigeonhole_sort(arr, ascending=True):',
      '    if not arr or len(arr) <= 1:',
      '        return arr',
      '',
      '    min_val = min(arr)',
      '    max_val = max(arr)',
      '    range_val = max_val - min_val + 1',
      '',
      '    pigeonholes = [[] for _ in range(range_val)]',
      '',
      '    for x in arr:',
      '        pigeonholes[x - min_val].append(x)',
      '',
      '    index = 0',
      '    arr_idx = 0 # Use a separate index for writing back to arr to avoid modifying it while iterating in Python example',
      '    temp_output = [0] * len(arr)',
      '',
      '    if ascending:',
      '        for i in range(range_val):',
      '            for x in pigeonholes[i]:',
      '                temp_output[arr_idx] = x',
      '                arr_idx += 1',
      '    else:  # Descending',
      '        for i in range(range_val - 1, -1, -1):',
      '            # For stable descending sort of duplicates, iterate hole in reverse or reverse hole first',
      '            # e.g., for x in reversed(pigeonholes[i]):',
      '            for x in pigeonholes[i]:',
      '                temp_output[arr_idx] = x',
      '                arr_idx += 1',
      '    ',
      '    # Copy temp_output back to arr',
      '    for i in range(len(arr)):',
      '        arr[i] = temp_output[i]',
      '    return arr',
    ],
  },
  pseudoCodeMapping: {
    0: { c: [23], cpp: [6], python: [1] },
    1: { c: [24], cpp: [7], python: [2, 3] },
    2: { c: [26, 27, 28], cpp: [9], python: [5] },
    3: { c: [26, 27, 28], cpp: [10], python: [6] },
    4: { c: [29], cpp: [11], python: [7] },
    5: { c: [31, 32, 33], cpp: [13], python: [9] },
    6: { c: [35], cpp: [15], python: [11] },
    7: { c: [36], cpp: [16], python: [12] },
    8: { c: [37], cpp: [17], python: [12] },
    9: { c: [39], cpp: [19], python: [14] },
    10: { c: [40], cpp: [20], python: [15] },
    11: { c: [41], cpp: [21], python: [16] },
    12: { c: [42], cpp: [22], python: [17] },
    13: { c: [43], cpp: [23], python: [18] },
    14: { c: [43], cpp: [23], python: [19] },
    15: { c: [44], cpp: [24], python: [19] },
    16: { c: [45], cpp: [25], python: [19] },
    17: { c: [46], cpp: [26], python: [20] },
    18: { c: [47], cpp: [27], python: [21] },
    19: { c: [48], cpp: [28], python: [23] },
    20: { c: [49], cpp: [29], python: [24] },
    21: { c: [49], cpp: [29], python: [25] },
    22: { c: [50], cpp: [30], python: [25] },
    23: { c: [51], cpp: [31], python: [25] },
    24: { c: [52], cpp: [32], python: [25] },
    25: { c: [58], cpp: [33], python: [26] },
    26: { c: [58], cpp: [33], python: [26] },
  },
  performancePaths: {
    best: [
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
      26,
    ],
    worst: [
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
      26,
    ],
    average: [
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
      26,
    ],
  },
  hasAdvancedAuxiliaryVisuals: true,
}
