'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { pigeonholeSortGenerator } from '../algorithms'

export const pigeonholeSortData: SortAlgorithm = {
  id: 'pigeonholeSort',
  name: 'Pigeonhole Sort',
  description:
    'Pigeonhole Sort is a sorting algorithm that is effective when the number of items and the range of possible key values are approximately the same. It works by creating an array of "pigeonholes," one for each key value in the range. The input elements are then placed into the corresponding pigeonholes. Finally, the sorted list is obtained by collecting the elements from the pigeonholes in order. It is similar to Counting Sort but directly places elements into the auxiliary array rather than just counting them.',
  generator: pigeonholeSortGenerator,
  complexity: {
    time: { best: 'O(n + N)', average: 'O(n + N)', worst: 'O(n + N)' },
    space: 'O(n + N)', // N is the range of key values, n is number of elements
  },
  origin: { name: 'E. J. Isaac & R. C. Singleton', year: 1956 },
  img: '',
  pseudoCodes: {
    plaintext: [
      'procedure pigeonholeSort(list)',
      '  minVal = findMinValue(list)',
      '  maxVal = findMaxValue(list)',
      '  rangeSize = maxVal - minVal + 1',
      '',
      '  pigeonholes = array of rangeSize empty lists',
      '',
      '  for each element in list',
      '    add element to pigeonholes[element - minVal]',
      '  end for',
      '',
      '  index = 0',
      '  for i = 0 to rangeSize - 1',
      '    for each element in pigeonholes[i]',
      '      list[index] = element',
      '      index = index + 1',
      '    end for',
      '  end for',
      'end procedure',
    ],
    c: [
      '#include <limits.h>',
      '#include <stdbool.h>',
      '#include <stdio.h> // For printf in a main, not strictly needed by sort',
      '#include <stdlib.h> // For malloc/free if we were using dynamic holes',
      '',
      'void pigeonholeSort(int arr[], int n, bool ascending) {',
      '  if (n == 0) return;',
      '',
      '  int minVal = arr[0], maxVal = arr[0];',
      '  for (int i = 1; i < n; i++) {',
      '    if (arr[i] < minVal) minVal = arr[i];',
      '    if (arr[i] > maxVal) maxVal = arr[i];',
      '  }',
      '  int rangeSize = maxVal - minVal + 1;',
      '',
      '  if (rangeSize <= 0) {',
      '      if (rangeSize == 1 && n > 0) { /* All elements same */ }',
      '      else return; ',
      '  }',
      '',
      '  // Using dynamic allocation for pigeonholes for robustness',
      '  // Outer array of pointers to int arrays (our "lists")',
      '  int** pigeonholes = (int**)malloc(rangeSize * sizeof(int*));',
      '  int* holeCapacities = (int*)malloc(rangeSize * sizeof(int));',
      '  int* holeCounts = (int*)malloc(rangeSize * sizeof(int));',
      '  if (!pigeonholes || !holeCapacities || !holeCounts) { /* Handle malloc failure */ free(pigeonholes); free(holeCapacities); free(holeCounts); return; }',
      '',
      '  for (int i = 0; i < rangeSize; i++) {',
      '    pigeonholes[i] = (int*)malloc(n * sizeof(int)); // Max capacity n for simplicity',
      '    if (!pigeonholes[i]) { /* Handle malloc failure */ /* Free previously allocated memory */ return; }',
      '    holeCapacities[i] = n;',
      '    holeCounts[i] = 0;',
      '  }',
      '',
      '  for (int i = 0; i < n; i++) {',
      '    int holeIndex = arr[i] - minVal;',
      '    if (holeIndex >= 0 && holeIndex < rangeSize) {',
      '      if (holeCounts[holeIndex] < holeCapacities[holeIndex]) {',
      '        pigeonholes[holeIndex][holeCounts[holeIndex]++] = arr[i];',
      '      }',
      '    }',
      '  }',
      '',
      '  int index = 0;',
      '  if (ascending) {',
      '    for (int i = 0; i < rangeSize; i++) {',
      '      for (int j = 0; j < holeCounts[i]; j++) {',
      '        if (index < n) {',
      '          arr[index++] = pigeonholes[i][j];',
      '        }',
      '      }',
      '    }',
      '  } else {',
      '    for (int i = rangeSize - 1; i >= 0; i--) {',
      '      for (int j = 0; j < holeCounts[i]; j++) {',
      '        if (index < n) {',
      '          arr[index++] = pigeonholes[i][j];',
      '        }',
      '      }',
      '    }',
      '  }',
      '',
      '  for (int i = 0; i < rangeSize; i++) {',
      '    free(pigeonholes[i]);',
      '  }',
      '  free(pigeonholes);',
      '  free(holeCapacities);',
      '  free(holeCounts);',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <algorithm>',
      '#include <numeric> // For std::iota if needed, not for this version',
      '',
      'void pigeonholeSort(std::vector<int>& arr, bool ascending) {',
      '  if (arr.empty()) return;',
      '',
      '  auto minMaxIt = std::minmax_element(arr.begin(), arr.end());',
      '  int minVal = *minMaxIt.first;',
      '  int maxVal = *minMaxIt.second;',
      '  int rangeSize = maxVal - minVal + 1;',
      '',
      '  if (rangeSize <= 0) { ',
      '      if (rangeSize == 1 && !arr.empty()) return;',
      '      return; ',
      '  }',
      '',
      '  std::vector<std::vector<int>> pigeonholes(rangeSize);',
      '',
      '  for (int x : arr) {',
      '    int holeIndex = x - minVal;',
      '    if (holeIndex >= 0 && holeIndex < rangeSize) {',
      '        pigeonholes[holeIndex].push_back(x);',
      '    }',
      '  }',
      '',
      '  int index = 0;',
      '  if (ascending) {',
      '    for (int i = 0; i < rangeSize; i++) {',
      '      for (int val : pigeonholes[i]) {',
      '        if (index < arr.size()) {',
      '            arr[index++] = val;',
      '        }',
      '      }',
      '    }',
      '  } else {',
      '    for (int i = rangeSize - 1; i >= 0; i--) {',
      '      for (int val : pigeonholes[i]) {',
      '        if (index < arr.size()) {',
      '            arr[index++] = val;',
      '        }',
      '      }',
      '    }',
      '  }',
      '}',
    ],
    python: [
      'def pigeonhole_sort(arr, ascending=True):',
      '    if not arr:',
      '        return arr',
      '',
      '    min_val = min(arr)',
      '    max_val = max(arr)',
      '    range_size = max_val - min_val + 1',
      '',
      '    if range_size <= 0:',
      '        if range_size == 1 and arr:',
      '             return arr',
      '        return arr ',
      '',
      '    pigeonholes = [[] for _ in range(range_size)]',
      '',
      '    for x in arr:',
      '        hole_index = x - min_val',
      '        if 0 <= hole_index < range_size:',
      '            pigeonholes[hole_index].append(x)',
      '',
      '    index = 0',
      '    if ascending:',
      '        for i in range(range_size):',
      '            for val in pigeonholes[i]:',
      '                if index < len(arr):',
      '                    arr[index] = val',
      '                    index += 1',
      '    else:',
      '        for i in range(range_size - 1, -1, -1):',
      '            for val in pigeonholes[i]:',
      '                if index < len(arr):',
      '                    arr[index] = val',
      '                    index += 1',
      '    return arr',
    ],
  },
  pseudoCodeMapping: {
    0: { c: [5, 6], cpp: [4, 5], python: [0, 1, 2] },
    1: { c: [8, 9, 10], cpp: [7, 8], python: [4] },
    2: { c: [8, 9, 11], cpp: [7, 9], python: [5] },
    3: { c: [13], cpp: [10], python: [6] },
    5: { c: [21, 26, 27, 28, 29, 30], cpp: [17], python: [13] },
    7: { c: [32], cpp: [19], python: [15] },
    8: { c: [33, 35], cpp: [20, 22], python: [16, 18] },
    9: { c: [39], cpp: [25], python: [20] },
    11: { c: [41], cpp: [27], python: [22] },
    12: { c: [43, 49], cpp: [29, 35], python: [24, 29] },
    13: { c: [44, 50], cpp: [30, 36], python: [25, 30] },
    14: { c: [46], cpp: [32, 38], python: [27, 32] },
    15: { c: [46], cpp: [32, 38], python: [28, 33] },
    16: { c: [48, 54], cpp: [34, 40], python: [] },
    17: { c: [49, 55], cpp: [35, 41], python: [] },
    18: { c: [63], cpp: [42], python: [35] },
  },
  hasAdvancedAuxiliaryVisuals: true,
}
