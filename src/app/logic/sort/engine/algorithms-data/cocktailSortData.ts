'use client'

import type { SortAlgorithm } from '../algorithmRegistry'
import { cocktailSortGenerator } from '../algorithms'

const rawPlaintextPseudoCode = [
  'procedure cocktailShakerSort(list, direction)',
  '  n = length of list',
  '  swapped = true',
  '  start = 0',
  '  end = n - 1',
  '  while swapped',
  '    swapped = false',
  '',
  '    for i = start to end - 1',
  '      if (direction == ASC and list[i] > list[i+1]) or (direction == DESC and list[i] < list[i+1]) then',
  '        swap(list[i], list[i + 1])',
  '        swapped = true',
  '      end if',
  '    end for',
  '',
  '    if not swapped then break',
  '',
  '    end = end - 1',
  '    swapped = false',
  '',
  '    for i = end - 1 down to start',
  '      if (direction == ASC and list[i] > list[i+1]) or (direction == DESC and list[i] < list[i+1]) then',
  '        swap(list[i], list[i + 1])',
  '        swapped = true',
  '      end if',
  '    end for',
  '',
  '    start = start + 1',
  '  end while',
  'end procedure',
]

export const cocktailSortData: SortAlgorithm = {
  id: 'cocktailSort',
  name: 'Cocktail Shaker Sort',
  description:
    'Also known as bidirectional bubble sort, cocktail shaker sort, or shaker sort, it is a variation of Bubble Sort that sorts in both directions on each pass through the list. It improves on Bubble Sort by moving items to their correct position more quickly, particularly by helping small items at the end of the list move to the beginning faster. However, its worst-case and average-case time complexity remains O(n^2).',
  generator: cocktailSortGenerator,
  complexity: { time: { best: 'O(n)', average: 'O(n^2)', worst: 'O(n^2)' }, space: 'O(1)' },
  origin: { name: 'Variation of Bubble Sort' },
  img: '',
  pseudoCode: rawPlaintextPseudoCode,
  languageExamples: {
    c: [
      '#include <stdbool.h>',
      '#include <stdio.h>',
      '',
      'void swapCocktail(int* xp, int* yp) {',
      '    int temp = *xp;',
      '    *xp = *yp;',
      '    *yp = temp;',
      '}',
      '',
      'void cocktailSort(int arr[], int n, bool ascending) {',
      '    bool swapped = true;',
      '    int start = 0;',
      '    int end = n - 1;',
      '',
      '    while (swapped) {',
      '        swapped = false;',
      '        for (int i = start; i < end; ++i) {',
      '            bool shouldSwapForward;',
      '            if (ascending) {',
      '                shouldSwapForward = (arr[i] > arr[i + 1]);',
      '            } else {',
      '                shouldSwapForward = (arr[i] < arr[i + 1]);',
      '            }',
      '            if (shouldSwapForward) {',
      '                swapCocktail(&arr[i], &arr[i + 1]);',
      '                swapped = true;',
      '            }',
      '        }',
      '        if (!swapped) break;',
      '        swapped = false;',
      '        --end;',
      '        for (int i = end - 1; i >= start; --i) {',
      '            bool shouldSwapBackward;',
      '            if (ascending) {',
      '                shouldSwapBackward = (arr[i] > arr[i + 1]);',
      '            } else {',
      '                shouldSwapBackward = (arr[i] < arr[i + 1]);',
      '            }',
      '            if (shouldSwapBackward) {',
      '                swapCocktail(&arr[i], &arr[i + 1]);',
      '                swapped = true;',
      '            }',
      '        }',
      '        ++start;',
      '    }',
      '}',
    ],
    cpp: [
      '#include <vector>',
      '#include <utility>',
      '#include <iostream>',
      '',
      'template <typename T>',
      'void cocktailSort(std::vector<T>& arr, bool ascending) {',
      '    int n = arr.size();',
      '    if (n == 0) return;',
      '    bool swapped = true;',
      '    int start = 0;',
      '    int end = n - 1;',
      '',
      '    while (swapped) {',
      '        swapped = false;',
      '        for (int i = start; i < end; ++i) {',
      '            bool shouldSwapForward;',
      '            if (ascending) {',
      '                shouldSwapForward = (arr[i] > arr[i + 1]);',
      '            } else {',
      '                shouldSwapForward = (arr[i] < arr[i + 1]);',
      '            }',
      '            if (shouldSwapForward) {',
      '                std::swap(arr[i], arr[i + 1]);',
      '                swapped = true;',
      '            }',
      '        }',
      '        if (!swapped) break;',
      '        swapped = false;',
      '        --end;',
      '        for (int i = end - 1; i >= start; --i) {',
      '            bool shouldSwapBackward;',
      '            if (ascending) {',
      '                shouldSwapBackward = (arr[i] > arr[i + 1]);',
      '            } else {',
      '                shouldSwapBackward = (arr[i] < arr[i + 1]);',
      '            }',
      '            if (shouldSwapBackward) {',
      '                std::swap(arr[i], arr[i + 1]);',
      '                swapped = true;',
      '            }',
      '        }',
      '        ++start;',
      '    }',
      '}',
    ],
    python: [
      'def cocktailSort(arr, ascending=True):',
      '    n = len(arr)',
      '    if n == 0:',
      '        return arr',
      '    swapped = True',
      '    start = 0',
      '    end = n - 1',
      '    while swapped:',
      '        swapped = False',
      '        for i in range(start, end):',
      '            shouldSwapForward = False',
      '            if ascending:',
      '                if arr[i] > arr[i + 1]:',
      '                    shouldSwapForward = True',
      '            else:',
      '                if arr[i] < arr[i + 1]:',
      '                    shouldSwapForward = True',
      '            if shouldSwapForward:',
      '                arr[i], arr[i + 1] = arr[i + 1], arr[i]',
      '                swapped = True',
      '        if not swapped:',
      '            break',
      '        swapped = False',
      '        end -= 1',
      '        for i in range(end - 1, start - 1, -1):',
      '            shouldSwapBackward = False',
      '            if ascending:',
      '                if arr[i] > arr[i + 1]:',
      '                    shouldSwapBackward = True',
      '            else:',
      '                if arr[i] < arr[i + 1]:',
      '                    shouldSwapBackward = True',
      '            if shouldSwapBackward:',
      '                arr[i], arr[i + 1] = arr[i + 1], arr[i]',
      '                swapped = True',
      '        start += 1',
      '    return arr',
    ],
  },
  pseudoCodeMapping: {
    0: { c: [10], cpp: [6], python: [1] },
    1: { c: [10], cpp: [7], python: [2] },
    2: { c: [11], cpp: [9], python: [5] },
    3: { c: [12], cpp: [10], python: [6] },
    4: { c: [13], cpp: [11], python: [7] },
    5: { c: [15], cpp: [13], python: [8] },
    6: { c: [16], cpp: [14], python: [9] },
    8: { c: [17], cpp: [15], python: [11] },
    9: { c: [18, 22], cpp: [16, 20], python: [12, 18] },
    10: { c: [24], cpp: [22], python: [19] },
    11: { c: [25], cpp: [23], python: [20] },
    12: { c: [26], cpp: [24], python: [20] },
    13: { c: [27], cpp: [25], python: [20] },
    15: { c: [28], cpp: [26], python: [22] },
    17: { c: [30], cpp: [28], python: [25] },
    18: { c: [29], cpp: [27], python: [24] },
    20: { c: [31], cpp: [29], python: [28] },
    21: { c: [32, 36], cpp: [30, 34], python: [29, 35] },
    22: { c: [38], cpp: [36], python: [36] },
    23: { c: [39], cpp: [37], python: [37] },
    24: { c: [40], cpp: [38], python: [37] },
    25: { c: [41], cpp: [39], python: [37] },
    27: { c: [43], cpp: [41], python: [38] },
    28: { c: [44], cpp: [42], python: [38] },
    29: { c: [45], cpp: [43], python: [39] },
  },
  performancePaths: {
    best: [0, 1, 2, 3, 4, 5, 6, 8, 9, 12, 13, 15, 28, 29],
    worst: [0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 17, 18, 20, 21, 22, 23, 24, 25, 27, 5],
    average: [0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 17, 18, 20, 21, 22, 23, 24, 25, 27, 5],
  },
  hasAdvancedAuxiliaryVisuals: false,
}
